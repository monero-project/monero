'\" t
.\" Automatically generated by Pandoc 2.18
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "monero-wallet-rpc" "1" "2022-06-30" "" ""
.hy
.SH NAME
.PP
monero-wallet-rpc - interface with wallet through RPC APIs.
.SH SYNOPSIS
.PP
\f[V]./monero-wallet-rpc --rpc-bind-port <port> (--wallet-file <file>|--generate-from-json <file>|--wallet-dir <directory>) [options]\f[R]
.PP
Or with a config file:
.PP
\f[V]./monero-wallet-rpc --config-file <arg>\f[R]
.PP
Make sure you are running a locally synced \f[V]monerod\f[R] or point to
a remote daemon with \f[V]--daemon-address\f[R] option.
.SH DESCRIPTION
.SS Provides wallet API over HTTP
.PP
Programmers can build thin user interfaces (UIs) on top of
\f[V]monero-wallet-rpc\f[R].
.PP
Programmers can also use \f[V]monero-wallet-rpc\f[R] to build arbitrary
wallet automation driven by HTTP calls.
.PP
Think of \f[V]monero-wallet-rpc\f[R] as complete wallet logic exposed
via JSON-RPC over HTTP.
.PP
Wallet uses your private keys to understand your total balance,
transactions history, and to facilitate creating transactions.
.PP
However, wallet does not store the blockchain and does not directly
participate in the p2p network.
.SS Depends on the full node
.PP
Wallet connects to a full node to scan the blockchain for your
transaction outputs and to send your transactions out to the network.
.PP
The full node can be either local (same computer) or remote.
.PP
You can play with CLI wallet and GUI wallet first to understand the
relationship between the full node, the wallet and the user.
.SS Linux (Production Example)
.PP
\f[V]./monero-wallet-rpc --rpc-bind-port 28088 --wallet-file wallets/main/main --password walletPassword --rpc-login monero:rpcPassword --log-file logs/monero-wallet-rpc.log --max-log-files 2 --trusted-daemon --non-interactive\f[R]
.IP \[bu] 2
If the RPC is used to retrieve information not dependent on any
spending, consider using a view-only to prevent abuse.
.IP \[bu] 2
\f[V]--rpc-login\f[R] should be used in production to protect against
any network attacks.
An uncommon password protects against the case where the RPC port is
open to the public
.SS Windows (Development Example)
.PP
\f[V]monero-wallet-rpc --rpc-bind-port 28088 --wallet-file wallets\[rs]main\[rs]main --password walletPassword --daemon-address http://node.supportxmr.com:18081 --untrusted-daemon --disable-rpc-login\f[R]
.IP \[bu] 2
Specifying \f[V]--untrusted-daemon\f[R] is not necessary but tells
yourself that the daemon is untrusted and that commands requiring a
trusted daemon will be disabled
.IP \[bu] 2
Default installation on Windows is
\f[V]\[dq]C:\[rs]Program Files\[rs]Monero GUI Wallet\[dq]\f[R]
.SS Trouble Shooting
.PP
If the expected RPC URL, say <http://127.0.0.1:28088/json_rpc>, is
unavailabe, or there is no terminal output saying that the server has
been started, \f[V]monero-wallet-rpc\f[R] might be trying to synchronize
the wallet.
In that case, you should use the GUI or CLI to sync that wallet file
because using the GUI/CLI results in faster and measurable syncing.
.PP
The suggested way is to have two wallet files for the same keys.
One that is used manually (synced often), and one that is used by
\f[V]monero-wallet-rpc\f[R].
Whenever you decide to use \f[V]monero-wallet-rpc\f[R] and encounter the
unresponsive issue, simply copy the files of the GUI/CLI wallet and
replace the ones that were being used by \f[V]monero-wallet-rpc\f[R].
This problem should only occur on the development system where
\f[V]monerod\f[R] or \f[V]monero-wallet-rpc\f[R] might not have been
running for weeks.
In production, \f[V]monerod\f[R] and \f[V]monero-wallet-rpc\f[R] should
have minimal downtimes, ensuring that the wallet is always synchronized.
.SH API CONVENTIONS
.PP
The API is based on JSON-RPC
standard (https://en.wikipedia.org/wiki/JSON-RPC) version 2.0.
.PP
All \f[V]monero-wallet-rpc\f[R] method calls use the same JSON-RPC
interface.
.PP
Assuming your \f[V]monero-wallet-rpc\f[R] is running on 127.0.0.1:18082,
you would call it like this:
.IP
.nf
\f[C]
IP=127.0.0.1
PORT=18082
METHOD=\[dq]make_integrated_address\[dq]
PARAMS=\[dq]{\[rs]\[dq]payment_id\[rs]\[dq]:\[rs]\[dq]1234567890123456789012345678900012345678901234567890123456789000\[rs]\[dq]}\[dq]
curl \[rs]
    -u username:password --digest \[rs]
    -X POST http://$IP:$PORT/json_rpc \[rs]
    -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]\[aq]$METHOD\[aq]\[dq],\[dq]params\[dq]:\[aq]\[dq]$PARAMS\[dq]\[aq]}\[aq] \[rs]
    -H \[aq]Content-Type: application/json\[aq]
\f[R]
.fi
.PP
The \f[B]atomic unit\f[R] used by the API is the smallest fraction of 1
XMR according to the monerod implementation.
1 XMR = 1e12 atomic units.
.SS Help and Version
.PP
.TS
tab(@);
l l.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--help\f[R]
T}@T{
Produce help message
T}
T{
\f[V]--version\f[R]
T}@T{
Output version information
T}
.TE
.SS Pick Network
.PP
.TS
tab(@);
l lx.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--testnet\f[R]
T}@T{
For testnet.
Daemon must also be launched with \[en]testnet flag
T}
T{
\f[V]--stagenet\f[R]
T}@T{
For stagenet.
Daemon must also be launched with \[en]stagenet flag
T}
.TE
.SS Logging
.PP
.TS
tab(@);
l lx.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--log-file <arg>\f[R]
T}@T{
Specify log file
T}
T{
\f[V]--log-level <arg>\f[R]
T}@T{
0-4 or categories
T}
T{
\f[V]--max-log-file-size <arg=104850000>\f[R]
T}@T{
Specify maximum log file size in bytes
T}
T{
\f[V]--max-log-files <arg=50>\f[R]
T}@T{
Specify maximum number of rotated log files to be saved (no limit by
setting to 0)
T}
.TE
.SS Daemon (Node)
.PP
.TS
tab(@);
l lx.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--daemon-address <arg>\f[R]
T}@T{
Use daemon instance at <host>:<port>
T}
T{
\f[V]--daemon-host <arg>\f[R]
T}@T{
Use daemon instance at host <arg> instead of localhost
T}
T{
\f[V]--proxy <arg>\f[R]
T}@T{
[<ip>:]<port> socks proxy to use for daemon connections
T}
T{
\f[V]--trusted-daemon\f[R]
T}@T{
Enable commands which rely on a trusted daemon
T}
T{
\f[V]--untrusted-daemon\f[R]
T}@T{
Disable commands which rely on a trusted daemon
T}
T{
\f[V]--password <arg>\f[R]
T}@T{
Wallet password (escape/quote as | needed)
T}
T{
\f[V]--password-file <arg>\f[R]
T}@T{
Wallet password file
T}
T{
\f[V]--daemon-port <arg=0>\f[R]
T}@T{
Use daemon instance at port <arg> instead of 18081
T}
T{
\f[V]--daemon-login <arg>\f[R]
T}@T{
Specify username[:password] for daemon RPC client
T}
T{
\f[V]--daemon-ssl <arg=autodetect)\f[R]
T}@T{
Enable SSL on daemon RPC connections: enabled|disabled|autodetect
T}
T{
\f[V]--daemon-ssl-private-key <arg>\f[R]
T}@T{
Path to a PEM format private key
T}
T{
\f[V]--daemon-ssl-certificate <arg>\f[R]
T}@T{
Path to a PEM format certificate
T}
T{
\f[V]--daemon-ssl-ca-certificates <arg>\f[R]
T}@T{
Path to file containing concatenated PEM format certificate(s) to
replace system CA(s).
T}
T{
\f[V]--daemon-ssl-allowed-fingerprints <arg>\f[R]
T}@T{
List of valid fingerprints of allowed RPC servers
T}
T{
\f[V]--daemon-ssl-allow-any-cert\f[R]
T}@T{
Allow any SSL certificate from the daemon
T}
T{
\f[V]--daemon-ssl-allow-chained\f[R]
T}@T{
Allow user (via \[en]daemon-ssl-ca-certificates) chain certificates
T}
.TE
.SS Other Useful
.PP
.TS
tab(@);
l lx.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--tx-notify <arg>\f[R]
T}@T{
Run a program for each new incoming transaction, `%s' will be replaced
by the transaction hash
T}
T{
\f[V]--non-interactive\f[R]
T}@T{
Run non-interactive (useful when input is DEVNULL)
T}
T{
\f[V]--config-file <arg>\f[R]
T}@T{
Config file
T}
.TE
.SS RPC
.PP
.TS
tab(@);
l lx.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--rpc-bind-port <arg>\f[R]
T}@T{
Sets bind port for server
T}
T{
\f[V]--disable-rpc-login\f[R]
T}@T{
Disable HTTP authentication for RPC connections served by this process
T}
T{
\f[V]--restricted-rpc\f[R]
T}@T{
Restricts to view-only commands
T}
T{
\f[V]--rpc-bind-ip <arg=127.0.0.1>\f[R]
T}@T{
Specify IP to bind RPC server
T}
T{
\f[V]--rpc-bind-ipv6-address <arg=::1>\f[R]
T}@T{
Specify IPv6 address to bind RPC server
T}
T{
\f[V]--rpc-restricted-bind-ip <arg=127.0.0.1>\f[R]
T}@T{
Specify IP to bind restricted RPC server
T}
T{
\f[V]--rpc-restricted-bind-ipv6-address <arg=::1>\f[R]
T}@T{
Specify IPv6 address to bind restricted RPC server
T}
T{
\f[V]--rpc-use-ipv6\f[R]
T}@T{
Allow IPv6 for RPC
T}
T{
\f[V]--rpc-ignore-ipv4\f[R]
T}@T{
Ignore unsuccessful IPv4 bind for RPC
T}
T{
\f[V]--rpc-login <arg>\f[R]
T}@T{
Specify username[:password] required for RPC server
T}
T{
\f[V]--confirm-external-bind\f[R]
T}@T{
Confirm rpc-bind-ip value is NOT a loopback (local) IP
T}
T{
\f[V]--rpc-access-control-origins <arg>\f[R]
T}@T{
Specify a comma separated list of origins to allow cross origin resource
sharing
T}
T{
\f[V]--rpc-ssl <arg=autodetect>\f[R]
T}@T{
Enable SSL on RPC connections: enabled|disabled|autodetect
T}
T{
\f[V]--rpc-ssl-private-key <arg>\f[R]
T}@T{
Path to a PEM format private key
T}
T{
\f[V]--rpc-ssl-certificate <arg>\f[R]
T}@T{
Path to a PEM format certificate
T}
T{
\f[V]--rpc-ssl-ca-certificates <arg>\f[R]
T}@T{
Path to file containing concatenated PEM format certificate(s) to
replace system CA(s).
T}
T{
\f[V]--rpc-ssl-allowed-fingerprints <arg>\f[R]
T}@T{
List of certificate fingerprints to allow
T}
T{
\f[V]--rpc-ssl-allow-chained\f[R]
T}@T{
Allow user (via \[en]rpc-ssl-certificates) chain certificates
T}
T{
\f[V]--disable-rpc-ban\f[R]
T}@T{
Do not ban hosts on RPC errors
T}
T{
\f[V]--rpc-client-secret-key <arg>\f[R]
T}@T{
Set RPC client secret key for RPC payments
T}
.TE
.SS Open Existing Wallet
.PP
.TS
tab(@);
l lx.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--wallet-file <arg>\f[R]
T}@T{
Use wallet <arg>
T}
T{
\f[V]--wallet-dir <arg>\f[R]
T}@T{
Directory for newly created wallets
T}
T{
\f[V]--prompt-for-password\f[R]
T}@T{
Prompts for password when not provided
T}
T{
\f[V]--max-concurrency <arg=0>\f[R]
T}@T{
Max number of threads to use for a parallel job
T}
.TE
.SS Create new Wallet
.PP
.TS
tab(@);
l lx.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--kdf-rounds <arg=1>\f[R]
T}@T{
Number of rounds for the key derivation function
T}
T{
\f[V]--hw-device <arg>\f[R]
T}@T{
HW device to use
T}
T{
\f[V]--hw-device-deriv-path <arg>\f[R]
T}@T{
HW device wallet derivation path (e.g., SLIP-10)
T}
T{
\f[V]--extra-entropy <arg>\f[R]
T}@T{
File containing extra entropy to initialize the PRNG (any data, aim for
256 bits of entropy to be useful, which typically means more than 256
its of data)
T}
T{
\f[V]--generate-from-json <arg>\f[R]
T}@T{
Generate wallet from JSON format file
T}
.TE
.SS Windows Service
.PP
.TS
tab(@);
l l.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--run-as-service\f[R]
T}@T{
true if running as windows service
T}
T{
\f[V]--install-service\f[R]
T}@T{
Install Windows service
T}
T{
\f[V]--uninstall-service\f[R]
T}@T{
Uninstall Windows service
T}
T{
\f[V]--start-service\f[R]
T}@T{
Start Windows service
T}
T{
\f[V]--stop-service\f[R]
T}@T{
Stop Windows service
T}
.TE
.SS Legacy and Rare Uses
.PP
.TS
tab(@);
l lx.
T{
Option
T}@T{
Description
T}
_
T{
\f[V]--shared-ringdb-dir <arg=C:\[rs]ProgramData\[rs].shared-ringdb, C:\[rs]ProgramData\[rs].shared-ringdb\[rs]testnet if \[aq]testnet\[aq], C:\[rs]ProgramData\[rs].shared-ringdb\[rs]stagenet if \[aq]stagenet\[aq]>\f[R]
T}@T{
Set shared ring database path
T}
T{
\f[V]--no-dns\f[R]
T}@T{
Do not use DNS
T}
T{
\f[V]--offline\f[R]
T}@T{
Do not connect to a daemon, nor use DNS
T}
T{
\f[V]--bitmessage-address <arg=http://localhost:8442/>\f[R]
T}@T{
Use PyBitmessage instance at URL <arg>
T}
T{
\f[V]--bitmessage-login <arg=username:password>\f[R]
T}@T{
Specify <arg> as username:password for PyBitmessage API
T}
.TE
.SS Index of JSON-RPC Methods
.PP
\f[B]add_address_book\f[R]
.PD 0
.P
.PD
\f[B]change_wallet_password\f[R]
.PD 0
.P
.PD
\f[B]check_reserve_proof\f[R]
.PD 0
.P
.PD
\f[B]check_spend_proof\f[R]
.PD 0
.P
.PD
\f[B]check_tx_key\f[R]
.PD 0
.P
.PD
\f[B]check_tx_proof\f[R]
.PD 0
.P
.PD
\f[B]close_wallet\f[R]
.PD 0
.P
.PD
\f[B]create_account\f[R]
.PD 0
.P
.PD
\f[B]create_address\f[R]
.PD 0
.P
.PD
\f[B]create_wallet\f[R]
.PD 0
.P
.PD
\f[B]delete_address_book\f[R]
.PD 0
.P
.PD
\f[B]export_key_images\f[R]
.PD 0
.P
.PD
\f[B]export_multisig_info\f[R]
.PD 0
.P
.PD
\f[B]export_outputs\f[R]
.PD 0
.P
.PD
\f[B]finalize_multisig\f[R]
.PD 0
.P
.PD
\f[B]get_account_tags\f[R]
.PD 0
.P
.PD
\f[B]get_accounts\f[R]
.PD 0
.P
.PD
\f[B]get_address\f[R]
.PD 0
.P
.PD
\f[B]get_address_book\f[R]
.PD 0
.P
.PD
\f[B]get_address_index\f[R]
.PD 0
.P
.PD
\f[B]get_attribute\f[R]
.PD 0
.P
.PD
\f[B]get_bulk_payments\f[R]
.PD 0
.P
.PD
\f[B]get_height\f[R]
.PD 0
.P
.PD
\f[B]get_languages\f[R]
.PD 0
.P
.PD
\f[B]get_payments\f[R]
.PD 0
.P
.PD
\f[B]get_reserve_proof\f[R]
.PD 0
.P
.PD
\f[B]get_spend_proof\f[R]
.PD 0
.P
.PD
\f[B]get_transfer_by_txid\f[R]
.PD 0
.P
.PD
\f[B]get_transfers\f[R]
.PD 0
.P
.PD
\f[B]get_tx_key\f[R]
.PD 0
.P
.PD
\f[B]get_tx_notes\f[R]
.PD 0
.P
.PD
\f[B]get_tx_proof\f[R]
.PD 0
.P
.PD
\f[B]get_version\f[R]
.PD 0
.P
.PD
\f[B]import_key_images\f[R]
.PD 0
.P
.PD
\f[B]import_multisig_info\f[R]
.PD 0
.P
.PD
\f[B]import_outputs\f[R]
.PD 0
.P
.PD
\f[B]incoming_transfers\f[R]
.PD 0
.P
.PD
\f[B]is_multisig\f[R]
.PD 0
.P
.PD
\f[B]label_account\f[R]
.PD 0
.P
.PD
\f[B]label_address\f[R]
.PD 0
.P
.PD
\f[B]make_integrated_address\f[R]
.PD 0
.P
.PD
\f[B]make_multisig\f[R]
.PD 0
.P
.PD
\f[B]make_uri\f[R]
.PD 0
.P
.PD
\f[B]open_wallet\f[R]
.PD 0
.P
.PD
\f[B]parse_uri\f[R]
.PD 0
.P
.PD
\f[B]prepare_multisig\f[R]
.PD 0
.P
.PD
\f[B]query_key\f[R]
.PD 0
.P
.PD
\f[B]refresh\f[R]
.PD 0
.P
.PD
\f[B]relay_tx\f[R]
.PD 0
.P
.PD
\f[B]rescan_blockchain\f[R]
.PD 0
.P
.PD
\f[B]rescan_spent\f[R]
.PD 0
.P
.PD
\f[B]set_account_tag_description\f[R]
.PD 0
.P
.PD
\f[B]set_attribute\f[R]
.PD 0
.P
.PD
\f[B]set_tx_notes\f[R]
.PD 0
.P
.PD
\f[B]sign\f[R]
.PD 0
.P
.PD
\f[B]sign_multisig\f[R]
.PD 0
.P
.PD
\f[B]sign_transfer\f[R]
.PD 0
.P
.PD
\f[B]split_integrated_address\f[R]
.PD 0
.P
.PD
\f[B]start_mining\f[R]
.PD 0
.P
.PD
\f[B]stop_mining\f[R]
.PD 0
.P
.PD
\f[B]stop_wallet\f[R]
.PD 0
.P
.PD
\f[B]store\f[R]
.PD 0
.P
.PD
\f[B]submit_multisig\f[R]
.PD 0
.P
.PD
\f[B]submit_transfer\f[R]
.PD 0
.P
.PD
\f[B]sweep_all\f[R]
.PD 0
.P
.PD
\f[B]sweep_dust\f[R]
.PD 0
.P
.PD
\f[B]sweep_single\f[R]
.PD 0
.P
.PD
\f[B]tag_accounts\f[R]
.PD 0
.P
.PD
\f[B]transfer\f[R]
.PD 0
.P
.PD
\f[B]transfer_split\f[R]
.PD 0
.P
.PD
\f[B]untag_accounts\f[R]
.PD 0
.P
.PD
\f[B]verify\f[R]
.PD 0
.P
.PD
.PD 0
.P
.PD
.SH JSON-RPC METHODS
.SS \f[B]add_address_book\f[R]
.PP
Add an entry to the address book.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]address\f[R] - string;
.IP \[bu] 2
\f[I]payment_id\f[R] - (optional) string, defaults to
\[lq]0000000000000000000000000000000000000000000000000000000000000000\[rq];
.IP \[bu] 2
\f[I]description\f[R] - (optional) string, defaults to \[lq]\[lq];
.PP
Outputs:
.IP \[bu] 2
\f[I]index\f[R] - unsigned int; The index of the address book entry.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]add_address_book\[dq],\[dq]params\[dq]:{\[dq]address\[dq]:\[dq]78P16M3XmFRGcWFCcsgt1WcTntA1jzcq31seQX1Eg92j8VQ99NPivmdKam4J5CKNAD7KuNWcq5xUPgoWczChzdba5WLwQ4j\[dq],\[dq]description\[dq]:\[dq]Third account\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]index\[dq]: 1
  }
}
\f[R]
.fi
.SS \f[B]change_wallet_password\f[R]
.PP
Change a wallet password.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]old_password\f[R] - string; (Optional) Current wallet password, if
defined.
.IP \[bu] 2
\f[I]new_password\f[R] - string; (Optional) New wallet password, if not
blank.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]change_wallet_password\[dq],\[dq]params\[dq]:{\[dq]old_password\[dq]:\[dq]theCurrentSecretPassPhrase\[dq],\[dq]new_password\[dq]:\[dq]theNewSecretPassPhrase\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]check_reserve_proof\f[R]
.PP
Proves a wallet has a disposable reserve using a signature.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]address\f[R] - string; Public address of the wallet.
.IP \[bu] 2
\f[I]message\f[R] - string; (Optional) Should be the same message used
in \f[V]get_reserve_proof\f[R].
.IP \[bu] 2
\f[I]signature\f[R] - string; reserve signature to confirm.
.PP
Outputs:
.IP \[bu] 2
\f[I]good\f[R] - boolean; States if the inputs proves the reserve.
.PP
In the example below, the reserve has been proven:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]check_reserve_proof\[dq],\[dq]params\[dq]:{\[dq]address\[dq]:\[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],\[dq]signature\[dq]:\[dq]ReserveProofV11BZ23sBt9sZJeGccf84mzyAmNCP3KzYbE1111112VKmH111118NfCYJQjZ6c46gT2kXgcHCaSSZeL8sRdzqjqx7i1e7FQfQGu2o113UYFVdwzHQi3iENDPa76Kn1BvywbKz3bMkXdZkBEEhBSF4kjjGaiMJ1ucKb6wvMVC4A8sA4nZEdL2Mk3wBucJCYTZwKqA8i1M113kqakDkG25FrjiDqdQTCYz2wDBmfKxF3eQiV5FWzZ6HmAyxnqTWUiMWukP9A3Edy3ZXqjP1b23dhz7Mbj39bBxe3ZeDNu9HnTSqYvHNRyqCkeUMJpHyQweqjGUJ1DSfFYr33J1E7MkhMnEi1o7trqWjVix32XLetYfePG73yvHbS24837L7Q64i5n1LSpd9yMiQZ3Dyaysi5y6jPx7TpAvnSqBFtuCciKoNzaXoA3dqt9cuVFZTXzdXKqdt3cXcVJMNxY8RvKPVQHhUur94Lpo1nSpxf7BN5a5rHrbZFqoZszsZmiWikYPkLX72XUdw6NWjLrTBxSy7KuPYH86c6udPEXLo2xgN6XHMBMBJzt8FqqK7EcpNUBkuHm2AtpGkf9CABY3oSjDQoRF5n4vNLd3qUaxNsG4XJ12L9gJ7GrK273BxkfEA8fDdxPrb1gpespbgEnCTuZHqj1A\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]good\[dq]: true,
    \[dq]spent\[dq]: 0,
    \[dq]total\[dq]: 100000000000
  }
}
\f[R]
.fi
.PP
In the example below, all wallet reserve has been proven:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]check_reserve_proof\[dq],\[dq]params\[dq]:{\[dq]address\[dq]:\[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],\[dq]message\[dq]:\[dq]I have 10 at least\[dq],\[dq]signature\[dq]:\[dq]...signature...\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]good\[dq]: true,
    \[dq]spent\[dq]: 0,
    \[dq]total\[dq]: 164113855714662789
  }
}
\f[R]
.fi
.PP
In the example below, the wrong message is used, avoiding the reserve to
be proved:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]check_spend_proof\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq],\[dq]message\[dq]:\[dq]wrong message\[dq],\[dq]signature\[dq]:\[dq]SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]good\[dq]: false
  }
}
\f[R]
.fi
.SS \f[B]check_spend_proof\f[R]
.PP
Prove a spend using a signature.
Unlike proving a transaction, it does not requires the destination
public address.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txid\f[R] - string; transaction id.
.IP \[bu] 2
\f[I]message\f[R] - string; (Optional) Should be the same message used
in \f[V]get_spend_proof\f[R].
.IP \[bu] 2
\f[I]signature\f[R] - string; spend signature to confirm.
.PP
Outputs:
.IP \[bu] 2
\f[I]good\f[R] - boolean; States if the inputs proves the spend.
.PP
In the example below, the spend has been proven:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]check_spend_proof\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq],\[dq]message\[dq]:\[dq]this is my transaction\[dq],\[dq]signature\[dq]:\[dq]SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]good\[dq]: true
  }
}
\f[R]
.fi
.PP
In the example below, the wrong message is used, avoiding the spend to
be proved:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]check_spend_proof\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq],\[dq]message\[dq]:\[dq]wrong message\[dq],\[dq]signature\[dq]:\[dq]SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]good\[dq]: false
  }
}
\f[R]
.fi
.SS \f[B]check_tx_key\f[R]
.PP
Check a transaction in the blockchain with its secret key.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txid\f[R] - string; transaction id.
.IP \[bu] 2
\f[I]tx_key\f[R] - string; transaction secret key.
.IP \[bu] 2
\f[I]address\f[R] - string; destination public address of the
transaction.
.PP
Outputs:
.IP \[bu] 2
\f[I]confirmations\f[R] - unsigned int; Number of block mined after the
one with the transaction.
.IP \[bu] 2
\f[I]in_pool\f[R] - boolean; States if the transaction is still in pool
or has been added to a block.
.IP \[bu] 2
\f[I]received\f[R] - unsigned int; Amount of the transaction.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]check_tx_key\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq],\[dq]tx_key\[dq]:\[dq]feba662cf8fb6d0d0da18fc9b70ab28e01cc76311278fdd7fe7ab16360762b06\[dq],\[dq]address\[dq]:\[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]confirmations\[dq]: 0,
    \[dq]in_pool\[dq]: false,
    \[dq]received\[dq]: 1000000000000
  }
}
\f[R]
.fi
.SS \f[B]check_tx_proof\f[R]
.PP
Prove a transaction by checking its signature.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txid\f[R] - string; transaction id.
.IP \[bu] 2
\f[I]address\f[R] - string; destination public address of the
transaction.
.IP \[bu] 2
\f[I]message\f[R] - string; (Optional) Should be the same message used
in \f[V]get_tx_proof\f[R].
.IP \[bu] 2
\f[I]signature\f[R] - string; transaction signature to confirm.
.PP
Outputs:
.IP \[bu] 2
\f[I]confirmations\f[R] - unsigned int; Number of block mined after the
one with the transaction.
.IP \[bu] 2
\f[I]good\f[R] - boolean; States if the inputs proves the transaction.
.IP \[bu] 2
\f[I]in_pool\f[R] - boolean; States if the transaction is still in pool
or has been added to a block.
.IP \[bu] 2
\f[I]received\f[R] - unsigned int; Amount of the transaction.
.PP
In the example below, the transaction has been proven:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]check_tx_proof\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq],\[dq]address\[dq]:\[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq],\[dq]message\[dq]:\[dq]this is my transaction\[dq],\[dq]signature\[dq]:\[dq]InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]confirmations\[dq]: 482,
    \[dq]good\[dq]: true,
    \[dq]in_pool\[dq]: false,
    \[dq]received\[dq]: 1000000000000
  }
}
\f[R]
.fi
.PP
In the example below, the wrong message is used, avoiding the
transaction to be proved:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]check_tx_proof\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq],\[dq]address\[dq]:\[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq],\[dq]message\[dq]:\[dq]wrong message\[dq],\[dq]signature\[dq]:\[dq]InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]confirmations\[dq]: 0,
    \[dq]good\[dq]: false,
    \[dq]in_pool\[dq]: false,
    \[dq]received\[dq]: 0
  }
}
\f[R]
.fi
.SS \f[B]close_wallet\f[R]
.PP
Close the currently opened wallet, after trying to save it.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]close_wallet\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]create_account\f[R]
.PP
Create a new account with an optional label.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]label\f[R] - string; (Optional) Label for the account.
.PP
Outputs:
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; Index of the new account.
.IP \[bu] 2
\f[I]address\f[R] - string; Address for this account.
Base58 representation of the public keys.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]create_account\[dq],\[dq]params\[dq]:{\[dq]label\[dq]:\[dq]Secondary account\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]account_index\[dq]: 1,
    \[dq]address\[dq]: \[dq]77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\[dq]
  }
}
\f[R]
.fi
.SS \f[B]create_address\f[R]
.PP
Create a new address for an account.
Optionally, label the new address.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; Create a new address for this
account.
.IP \[bu] 2
\f[I]label\f[R] - string; (Optional) Label for the new address.
.PP
Outputs:
.IP \[bu] 2
\f[I]address\f[R] - string; Newly created address.
Base58 representation of the public keys.
.IP \[bu] 2
\f[I]address_index\f[R] - unsigned int; Index of the new address under
the input account.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]create_address\[dq],\[dq]params\[dq]:{\[dq]account_index\[dq]:0,\[dq]label\[dq]:\[dq]new-sub\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]address\[dq]: \[dq]7BG5jr9QS5sGMdpbBrZEwVLZjSKJGJBsXdZLt8wiXyhhLjy7x2LZxsrAnHTgD8oG46ZtLjUGic2pWc96GFkGNPQQDA3Dt7Q\[dq],
    \[dq]address_index\[dq]: 5
  }
}
\f[R]
.fi
.SS \f[B]create_wallet\f[R]
.PP
Create a new wallet.
You need to have set the argument \[lq]\[en]wallet-dir\[rq] when
launching monero-wallet-rpc to make this work.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]filename\f[R] - string; Wallet file name.
.IP \[bu] 2
\f[I]password\f[R] - string; (Optional) password to protect the wallet.
.IP \[bu] 2
\f[I]language\f[R] - string; Language for your wallets\[cq] seed.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]create_wallet\[dq],\[dq]params\[dq]:{\[dq]filename\[dq]:\[dq]mytestwallet\[dq],\[dq]password\[dq]:\[dq]mytestpassword\[dq],\[dq]language\[dq]:\[dq]English\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]delete_address_book\f[R]
.PP
Delete an entry from the address book.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]index\f[R] - unsigned int; The index of the address book entry.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]delete_address_book\[dq],\[dq]params\[dq]:{\[dq]index\[dq]:1}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]export_key_images\f[R]
.PP
Export a signed set of key images.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]signed_key_images\f[R] - array of signed key images:
.RS 2
.IP \[bu] 2
\f[I]key_image\f[R] - string;
.IP \[bu] 2
\f[I]signature\f[R] - string;
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]export_key_images\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]signed_key_images\[dq]: [{
      \[dq]key_image\[dq]: \[dq]cd35239b72a35e26a57ed17400c0b66944a55de9d5bda0f21190fed17f8ea876\[dq],
      \[dq]signature\[dq]: \[dq]c9d736869355da2538ab4af188279f84138c958edbae3c5caf388a63cd8e780b8c5a1aed850bd79657df659422c463608ea4e0c730ba9b662c906ae933816d00\[dq]
    },{
      \[dq]key_image\[dq]: \[dq]65158a8ee5a3b32009b85a307d85b375175870e560e08de313531c7dbbe6fc19\[dq],
      \[dq]signature\[dq]: \[dq]c96e40d09dfc45cfc5ed0b76bfd7ca793469588bb0cf2b4d7b45ef23d40fd4036057b397828062e31700dc0c2da364f50cd142295a8405b9fe97418b4b745d0c\[dq]
    },...]
  }
}
\f[R]
.fi
.SS \f[B]export_multisig_info\f[R]
.PP
Export multisig info for other participants.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]info\f[R] - string; Multisig info in hex format for other
participants.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]export_multisig_info\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]info\[dq]: \[dq]4d6f6e65726f206d756c7469736967206578706f72740105cf6442b09b75f5eca9d846771fe1a879c9a97ab0553ffbcec64b1148eb7832b51e7898d7944c41cee000415c5a98f4f80dc0efdae379a98805bb6eacae743446f6f421cd03e129eb5b27d6e3b73eb6929201507c1ae706c1a9ecd26ac8601932415b0b6f49cbbfd712e47d01262c59980a8f9a8be776f2bf585f1477a6df63d6364614d941ecfdcb6e958a390eb9aa7c87f056673d73bc7c5f0ab1f74a682e902e48a3322c0413bb7f6fd67404f13fb8e313f70a0ce568c853206751a334ef490068d3c8ca0e\[dq]
  }
}
\f[R]
.fi
.SS \f[B]export_outputs\f[R]
.PP
Export all outputs in hex format.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]outputs_data_hex\f[R] - string; wallet outputs in hex format.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]export_outputs\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]outputs_data_hex\[dq]: \[dq]...outputs...\[dq]
  }
}
\f[R]
.fi
.SS \f[B]finalize_multisig\f[R]
.PP
Turn this wallet into a multisig wallet, extra step for N-1/N wallets.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]multisig_info\f[R] - array of string; List of multisig string from
peers.
.IP \[bu] 2
\f[I]password\f[R] - string; Wallet password
.PP
Outputs:
.IP \[bu] 2
\f[I]address\f[R] - string; multisig wallet address.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]finalize_multisig\[dq],\[dq]params\[dq]:{\[dq]multisig_info\[dq]:[\[dq]MultisigxV1JNC6Ja2oBt5Sqea9LN2YEF7WYZCpHqr2EKvPG89Trf3X4E8RWkLaGRf29fJ3stU471MELKxwufNYeigP7LoE4tn2McPr4SbL9q15xNvZT5uwC9YRr7UwjXqSZHmTWN9PBuZEKVAQ4HPPyQciSCdNjgwsuFRBzrskMdMUwNMgKst1debYfm37i6PSzDoS2tk4kYTYj83kkAdR7kdshet1axQPd6HQ\[dq],\[dq]MultisigxV1Unma7Ko4zdd8Ps3Af4oZwtj2JdWKzwNfP6s2G9ZvXhMoSscwn5g7PyCfcBc1V4ffRHY3Kxqq6VocSCUTncpVeUskMcPr4SbL9q15xNvZT5uwC9YRr7UwjXqSZHmTWN9PBuZE1LTpWxLoC3vPMSrqVVcjnmL9LYfdCZz3fECjNZbCEDq3PHDiUuY5jurQTcNoGhDTio5WM9xaAdim9YByiS5KyqF4\[dq]]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]address\[dq]: \[dq]5B9gZUTDuHTcGGuY3nL3t8K2tDnEHeRVHSBQgLZUTQxtFYVLnho5JJjWJyFp5YZgZRQ44RiviJi1sPHgLVMbckRsDqDx1gV\[dq]
  }
}
\f[R]
.fi
.SS \f[B]get_account_tags\f[R]
.PP
Get a list of user-defined account tags.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]account_tags\f[R] - array of account tag information:
.RS 2
.IP \[bu] 2
\f[I]tag\f[R] - string; Filter tag.
.IP \[bu] 2
\f[I]label\f[R] - string; Label for the tag.
.IP \[bu] 2
\f[I]accounts\f[R] - array of int; List of tagged account indices.
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_account_tags\[dq],\[dq]params\[dq]:\[dq]\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]account_tags\[dq]: [{
      \[dq]accounts\[dq]: [0],
      \[dq]label\[dq]: \[dq]Test tag\[dq],
      \[dq]tag\[dq]: \[dq]myTag\[dq]
    }]
  }
}
\f[R]
.fi
.SS \f[B]get_accounts\f[R]
.PP
Get all accounts for a wallet.
Optionally filter accounts by tag.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]tag\f[R] - string; (Optional) Tag for filtering accounts.
.PP
Outputs:
.IP \[bu] 2
\f[I]subaddress_accounts\f[R] - array of subaddress account information:
.RS 2
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; Index of the account.
.IP \[bu] 2
\f[I]balance\f[R] - unsigned int; Balance of the account (locked or
unlocked).
.IP \[bu] 2
\f[I]base_address\f[R] - string; Base64 representation of the first
subaddress in the account.
.IP \[bu] 2
\f[I]label\f[R] - string; (Optional) Label of the account.
.IP \[bu] 2
\f[I]tag\f[R] - string; (Optional) Tag for filtering accounts.
.IP \[bu] 2
\f[I]unlocked_balance\f[R] - unsigned int; Unlocked balance for the
account.
.RE
.IP \[bu] 2
\f[I]total_balance\f[R] - unsigned int; Total balance of the selected
accounts (locked or unlocked).
.IP \[bu] 2
\f[I]total_unlocked_balance\f[R] - unsigned int; Total unlocked balance
of the selected accounts.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_accounts\[dq],\[dq]params\[dq]:{\[dq]tag\[dq]:\[dq]myTag\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]subaddress_accounts\[dq]: [{
      \[dq]account_index\[dq]: 0,
      \[dq]balance\[dq]: 157663195572433688,
      \[dq]base_address\[dq]: \[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],
      \[dq]label\[dq]: \[dq]Primary account\[dq],
      \[dq]tag\[dq]: \[dq]myTag\[dq],
      \[dq]unlocked_balance\[dq]: 157443303037455077
    },{
      \[dq]account_index\[dq]: 1,
      \[dq]balance\[dq]: 0,
      \[dq]base_address\[dq]: \[dq]77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\[dq],
      \[dq]label\[dq]: \[dq]Secondary account\[dq],
      \[dq]tag\[dq]: \[dq]myTag\[dq],
      \[dq]unlocked_balance\[dq]: 0
    }],
    \[dq]total_balance\[dq]: 157663195572433688,
    \[dq]total_unlocked_balance\[dq]: 157443303037455077
  }
}
\f[R]
.fi
.SS \f[B]get_address\f[R]
.PP
Return the wallet\[cq]s addresses for an account.
Optionally filter for specific set of subaddresses.
.PP
Alias: \f[I]getaddress\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; Return subaddresses for this
account.
.IP \[bu] 2
\f[I]address_index\f[R] - array of unsigned int; (Optional) List of
subaddresses to return from an account.
.PP
Outputs:
.IP \[bu] 2
\f[I]address\f[R] - string; The 95-character hex address string of the
monero-wallet-rpc in session.
.IP \[bu] 2
\f[I]addresses\f[R] array of addresses informations
.RS 2
.IP \[bu] 2
\f[I]address\f[R] string; The 95-character hex (sub)address string.
.IP \[bu] 2
\f[I]label\f[R] string; Label of the (sub)address
.IP \[bu] 2
\f[I]address_index\f[R] unsigned int; index of the subaddress
.IP \[bu] 2
\f[I]used\f[R] boolean; states if the (sub)address has already received
funds
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_address\[dq],\[dq]params\[dq]:{\[dq]account_index\[dq]:0,\[dq]address_index\[dq]:[0,1,4]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]address\[dq]: \[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],
    \[dq]addresses\[dq]: [{
      \[dq]address\[dq]: \[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],
      \[dq]address_index\[dq]: 0,
      \[dq]label\[dq]: \[dq]Primary account\[dq],
      \[dq]used\[dq]: true
    },{
      \[dq]address\[dq]: \[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq],
      \[dq]address_index\[dq]: 1,
      \[dq]label\[dq]: \[dq]\[dq],
      \[dq]used\[dq]: true
    },{
      \[dq]address\[dq]: \[dq]77xa6Dha7kzCQuvmd8iB5VYoMkdenwCNRU9khGhExXQ8KLL3z1N1ZATBD1sFPenyHWT9cm4fVFnCAUApY53peuoZFtwZiw5\[dq],
      \[dq]address_index\[dq]: 4,
      \[dq]label\[dq]: \[dq]test2\[dq],
      \[dq]used\[dq]: true
    }]
  }
}
\f[R]
.fi
.SS \f[B]get_address_book\f[R]
.PP
Retrieves entries from the address book.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]entries\f[R] - array of unsigned int; indices of the requested
address book entries
.PP
Outputs:
.IP \[bu] 2
\f[I]entries\f[R] - array of entries:
.RS 2
.IP \[bu] 2
\f[I]address\f[R] - string; Public address of the entry
.IP \[bu] 2
\f[I]description\f[R] - string; Description of this address entry
.IP \[bu] 2
\f[I]index\f[R] - unsigned int;
.IP \[bu] 2
\f[I]payment_id\f[R] - string;
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_address_book\[dq],\[dq]params\[dq]:{\[dq]entries\[dq]:[0,1]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]entries\[dq]: [{
      \[dq]address\[dq]: \[dq]77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\[dq],
      \[dq]description\[dq]: \[dq]Second account\[dq],
      \[dq]index\[dq]: 0,
      \[dq]payment_id\[dq]: \[dq]0000000000000000000000000000000000000000000000000000000000000000\[dq]
    },{
      \[dq]address\[dq]: \[dq]78P16M3XmFRGcWFCcsgt1WcTntA1jzcq31seQX1Eg92j8VQ99NPivmdKam4J5CKNAD7KuNWcq5xUPgoWczChzdba5WLwQ4j\[dq],
      \[dq]description\[dq]: \[dq]Third account\[dq],
      \[dq]index\[dq]: 1,
      \[dq]payment_id\[dq]: \[dq]0000000000000000000000000000000000000000000000000000000000000000\[dq]
    }]
  }
}
\f[R]
.fi
.SS \f[B]get_address_index\f[R]
.PP
Get account and address indexes from a specific (sub)address
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]address\f[R] - String; (sub)address to look for.
.PP
Outputs:
.IP \[bu] 2
\f[I]index\f[R] - subaddress informations
.RS 2
.IP \[bu] 2
\f[I]major\f[R] unsigned int; Account index.
.IP \[bu] 2
\f[I]minor\f[R] unsigned int; Address index.
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_address_index\[dq],\[dq]params\[dq]:{\[dq]address\[dq]:\[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]index\[dq]: {
      \[dq]major\[dq]: 0,
      \[dq]minor\[dq]: 1
    }
  }
}
\f[R]
.fi
.SS \f[B]get_attribute\f[R]
.PP
Get attribute value by name.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]key\f[R] - string; attribute name
.PP
Outputs:
.IP \[bu] 2
\f[I]value\f[R] - string; attribute value
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_attribute\[dq],\[dq]params\[dq]:{\[dq]key\[dq]:\[dq]my_attribute\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]value\[dq]: \[dq]my_value\[dq]
  }
}
\f[R]
.fi
.SS \f[B]get_bulk_payments\f[R]
.PP
Get a list of incoming payments using a given payment id, or a list of
payments ids, from a given height.
This method is the preferred method over \f[V]get_payments\f[R]because
it has the same functionality but is more extendable.
Either is fine for looking up transactions by a single payment ID.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]payment_ids\f[R] - array of: string; Payment IDs used to find the
payments (16 characters hex).
.IP \[bu] 2
\f[I]min_block_height\f[R] - unsigned int; The block height at which to
start looking for payments.
.PP
Outputs:
.IP \[bu] 2
\f[I]payments\f[R] - list of:
.RS 2
.IP \[bu] 2
\f[I]payment_id\f[R] - string; Payment ID matching one of the input IDs.
.IP \[bu] 2
\f[I]tx_hash\f[R] - string; Transaction hash used as the transaction ID.
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount for this payment.
.IP \[bu] 2
\f[I]block_height\f[R] - unsigned int; Height of the block that first
confirmed this payment.
.IP \[bu] 2
\f[I]unlock_time\f[R] - unsigned int; Time (in block height) until this
payment is safe to spend.
.IP \[bu] 2
\f[I]subaddr_index\f[R] - subaddress index:
.RS 2
.IP \[bu] 2
\f[I]major\f[R] - unsigned int; Account index for the subaddress.
.IP \[bu] 2
\f[I]minor\f[R] - unsigned int; Index of the subaddress in the account.
.RE
.IP \[bu] 2
\f[I]address\f[R] - string; Address receiving the payment; Base58
representation of the public keys.
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_bulk_payments\[dq],\[dq]params\[dq]:{\[dq]payment_ids\[dq]:[\[dq]60900e5603bf96e3\[dq]],\[dq]min_block_height\[dq]:\[dq]120000\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]payments\[dq]: [{
      \[dq]address\[dq]: \[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],
      \[dq]amount\[dq]: 1000000000000,
      \[dq]block_height\[dq]: 127606,
      \[dq]payment_id\[dq]: \[dq]60900e5603bf96e3\[dq],
      \[dq]subaddr_index\[dq]: {
        \[dq]major\[dq]: 0,
        \[dq]minor\[dq]: 0
      },
      \[dq]tx_hash\[dq]: \[dq]3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\[dq],
      \[dq]unlock_time\[dq]: 0
    }]
  }
}
\f[R]
.fi
.SS \f[B]get_height\f[R]
.PP
Returns the wallet\[cq]s current block height.
.PP
Alias: \f[I]getheight\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]height\f[R] - unsigned int; The current monero-wallet-rpc\[cq]s
blockchain height.
If the wallet has been offline for a long time, it may need to catch up
with the daemon.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_height\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]height\[dq]: 145545
  }
}
\f[R]
.fi
.SS \f[B]get_languages\f[R]
.PP
Get a list of available languages for your wallet\[cq]s seed.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]languages\f[R] - array of string; List of available languages
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_languages\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]languages\[dq]: [\[dq]Deutsch\[dq],\[dq]English\[dq],\[dq]Espa\[~n]ol\[dq],\[dq]Fran\[,c]ais\[dq],\[dq]Italiano\[dq],\[dq]Nederlands\[dq],\[dq]Portugu\[^e]s\[dq],\[dq]\[u0440]\[u0443]\[u0441]\[u0441]\[u043A]\[u0438]\[u0439] \[u044F]\[u0437]\[u044B]\[u043A]\[dq],\[dq]\[u65E5]\[u672C]\[u8A9E]\[dq],\[dq]\[u7B80]\[u4F53]\[u4E2D]\[u6587] (\[u4E2D]\[u56FD])\[dq],\[dq]Esperanto\[dq],\[dq]Lojban\[dq]]
  }
}
\f[R]
.fi
.SS \f[B]get_payments\f[R]
.PP
Get a list of incoming payments using a given payment id.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]payment_id\f[R] - string; Payment ID used to find the payments (16
characters hex).
.PP
Outputs:
.IP \[bu] 2
\f[I]payments\f[R] - list of:
.RS 2
.IP \[bu] 2
\f[I]payment_id\f[R] - string; Payment ID matching the input parameter.
.IP \[bu] 2
\f[I]tx_hash\f[R] - string; Transaction hash used as the transaction ID.
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount for this payment.
.IP \[bu] 2
\f[I]block_height\f[R] - unsigned int; Height of the block that first
confirmed this payment.
.IP \[bu] 2
\f[I]unlock_time\f[R] - unsigned int; Time (in block height) until this
payment is safe to spend.
.IP \[bu] 2
\f[I]subaddr_index\f[R] - subaddress index:
.RS 2
.IP \[bu] 2
\f[I]major\f[R] - unsigned int; Account index for the subaddress.
.IP \[bu] 2
\f[I]minor\f[R] - unsigned int; Index of the subaddress in the account.
.RE
.IP \[bu] 2
\f[I]address\f[R] - string; Address receiving the payment; Base58
representation of the public keys.
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_payments\[dq],\[dq]params\[dq]:{\[dq]payment_id\[dq]:\[dq]60900e5603bf96e3\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]payments\[dq]: [{
      \[dq]address\[dq]: \[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],
      \[dq]amount\[dq]: 1000000000000,
      \[dq]block_height\[dq]: 127606,
      \[dq]payment_id\[dq]: \[dq]60900e5603bf96e3\[dq],
      \[dq]subaddr_index\[dq]: {
        \[dq]major\[dq]: 0,
        \[dq]minor\[dq]: 0
      },
      \[dq]tx_hash\[dq]: \[dq]3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\[dq],
      \[dq]unlock_time\[dq]: 0
    }]
  }
}
\f[R]
.fi
.SS \f[B]get_reserve_proof\f[R]
.PP
Generate a signature to prove of an available amount in a wallet.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]all\f[R] - boolean; Proves all wallet balance to be disposable.
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; Specify the account from witch
to prove reserve.
(ignored if \f[V]all\f[R] is set to true)
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount (in atomic units) to prove the
account has for reserve.
(ignored if \f[V]all\f[R] is set to true)
.IP \[bu] 2
\f[I]message\f[R] - string; (Optional) add a message to the signature to
further authenticate the prooving process.
.PP
Outputs:
.IP \[bu] 2
\f[I]signature\f[R] - string; reserve signature.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_reserve_proof\[dq],\[dq]params\[dq]:{\[dq]all\[dq]:false,\[dq]account_index\[dq]:0,\[dq]amount\[dq]:100000000000}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]signature\[dq]: \[dq]ReserveProofV11BZ23sBt9sZJeGccf84mzyAmNCP3KzYbE1111112VKmH111118NfCYJQjZ6c46gT2kXgcHCaSSZeL8sRdzqjqx7i1e7FQfQGu2o113UYFVdwzHQi3iENDPa76Kn1BvywbKz3bMkXdZkBEEhBSF4kjjGaiMJ1ucKb6wvMVC4A8sA4nZEdL2Mk3wBucJCYTZwKqA8i1M113kqakDkG25FrjiDqdQTCYz2wDBmfKxF3eQiV5FWzZ6HmAyxnqTWUiMWukP9A3Edy3ZXqjP1b23dhz7Mbj39bBxe3ZeDNu9HnTSqYvHNRyqCkeUMJpHyQweqjGUJ1DSfFYr33J1E7MkhMnEi1o7trqWjVix32XLetYfePG73yvHbS24837L7Q64i5n1LSpd9yMiQZ3Dyaysi5y6jPx7TpAvnSqBFtuCciKoNzaXoA3dqt9cuVFZTXzdXKqdt3cXcVJMNxY8RvKPVQHhUur94Lpo1nSpxf7BN5a5rHrbZFqoZszsZmiWikYPkLX72XUdw6NWjLrTBxSy7KuPYH86c6udPEXLo2xgN6XHMBMBJzt8FqqK7EcpNUBkuHm2AtpGkf9CABY3oSjDQoRF5n4vNLd3qUaxNsG4XJ12L9gJ7GrK273BxkfEA8fDdxPrb1gpespbgEnCTuZHqj1A\[dq]
  }
}
\f[R]
.fi
.SS \f[B]get_spend_proof\f[R]
.PP
Generate a signature to prove a spend.
Unlike proving a transaction, it does not requires the destination
public address.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txid\f[R] - string; transaction id.
.IP \[bu] 2
\f[I]message\f[R] - string; (Optional) add a message to the signature to
further authenticate the prooving process.
.PP
Outputs:
.IP \[bu] 2
\f[I]signature\f[R] - string; spend signature.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_spend_proof\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq],\[dq]message\[dq]:\[dq]this is my transaction\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]signature\[dq]: \[dq]SpendProofV1aSh8Todhk54736iXgV6vJAFP7egxByuMWZeyNDaN2JY737S95X5zz5mNMQSuCNSLjjhi5HJCsndpNWSNVsuThxwv285qy1KkUrLFRkxMSCjfL6bbycYN33ScZ5UB4Fzseceo1ndpL393T1q638VmcU3a56dhNHF1RPZFiGPS61FA78nXFSqE9uoKCCoHkEz83M1dQVhxZV5CEPF2P6VioGTKgprLCH9vvj9k1ivd4SX19L2VSMc3zD1u3mkR24ioETvxBoLeBSpxMoikyZ6inhuPm8yYo9YWyFtQK4XYfAV9mJ9knz5fUPXR8vvh7KJCAg4dqeJXTVb4mbMzYtsSZXHd6ouWoyCd6qMALdW8pKhgMCHcVYMWp9X9WHZuCo9rsRjRpg15sJUw7oJg1JoGiVgj8P4JeGDjnZHnmLVa5bpJhVCbMhyM7JLXNQJzFWTGC27TQBbthxCfQaKdusYnvZnKPDJWSeceYEFzepUnsWhQtyhbb73FzqgWC4eKEFKAZJqT2LuuSoxmihJ9acnFK7Ze23KTVYgDyMKY61VXADxmSrBvwUtxCaW4nQtnbMxiPMNnDMzeixqsFMBtN72j5UqhiLRY99k6SE7Qf5f29haNSBNSXCFFHChPKNTwJrehkofBdKUhh2VGPqZDNoefWUwfudeu83t85bmjv8Q3LrQSkFgFjRT5tLo8TMawNXoZCrQpyZrEvnodMDDUUNf3NL7rxyv3gM1KrTWjYaWXFU2RAsFee2Q2MTwUW7hR25cJvSFuB1BX2bfkoCbiMk923tHZGU2g7rSKF1GDDkXAc1EvFFD4iGbh1Q5t6hPRhBV8PEncdcCWGq5uAL5D4Bjr6VXG8uNeCy5oYWNgbZ5JRSfm7QEhPv8Fy9AKMgmCxDGMF9dVEaU6tw2BAnJavQdfrxChbDBeQXzCbCfep6oei6n2LZdE5Q84wp7eoQFE5Cwuo23tHkbJCaw2njFi3WGBbA7uGZaGHJPyB2rofTWBiSUXZnP2hiE9bjJghAcDm1M4LVLfWvhZmFEnyeru3VWMETnetz1BYLUC5MJGFXuhnHwWh7F6r74FDyhdswYop4eWPbyrXMXmUQEccTGd2NaT8g2VHADZ76gMC6BjWESvcnz2D4n8XwdmM7ZQ1jFwhuXrBfrb1dwRasyXxxHMGAC2onatNiExyeQ9G1W5LwqNLAh9hvcaNTGaYKYXoceVzLkgm6e5WMkLsCwuZXvB\[dq]
  }
}
\f[R]
.fi
.SS \f[B]get_transfer_by_txid\f[R]
.PP
Show information about a transfer to/from this address.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txid\f[R] - string; Transaction ID used to find the transfer.
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; (Optional) Index of the account
to query for the transfer.
.PP
Outputs:
.IP \[bu] 2
\f[I]transfer\f[R] - JSON object containing payment information:
.RS 2
.IP \[bu] 2
\f[I]address\f[R] - string; Address that transferred the funds.
Base58 representation of the public keys.
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount of this transfer.
.IP \[bu] 2
\f[I]confirmations\f[R] - unsigned int; Number of block mined since the
block containing this transaction (or block height at which the
transaction should be added to a block if not yet confirmed).
.IP \[bu] 2
\f[I]destinations\f[R] - array of JSON objects containing transfer
destinations:
.RS 2
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount transferred to this destination.
.IP \[bu] 2
\f[I]address\f[R] - string; Address for this destination.
Base58 representation of the public keys.
.RE
.IP \[bu] 2
\f[I]double_spend_seen\f[R] - boolean; True if the key image(s) for the
transfer have been seen before.
.IP \[bu] 2
\f[I]fee\f[R] - unsigned int; Transaction fee for this transfer.
.IP \[bu] 2
\f[I]height\f[R] - unsigned int; Height of the first block that
confirmed this transfer.
.IP \[bu] 2
\f[I]note\f[R] - string; Note about this transfer.
.IP \[bu] 2
\f[I]payment_id\f[R] - string; Payment ID for this transfer.
.IP \[bu] 2
\f[I]subaddr_index\f[R] - JSON object containing the major & minor
subaddress index:
.RS 2
.IP \[bu] 2
\f[I]major\f[R] - unsigned int; Account index for the subaddress.
.IP \[bu] 2
\f[I]minor\f[R] - unsigned int; Index of the subaddress under the
account.
.RE
.IP \[bu] 2
\f[I]suggested_confirmations_threshold\f[R] - unsigned int; Estimation
of the confirmations needed for the transaction to be included in a
block.
.IP \[bu] 2
\f[I]timestamp\f[R] - unsigned int; POSIX timestamp for the block that
confirmed this transfer (or timestamp submission if not mined yet).
.IP \[bu] 2
\f[I]txid\f[R] - string; Transaction ID of this transfer (same as input
TXID).
.IP \[bu] 2
\f[I]type\f[R] - string; Type of transfer, one of the following:
\[lq]in\[rq], \[lq]out\[rq], \[lq]pending\[rq], \[lq]failed\[rq],
\[lq]pool\[rq]
.IP \[bu] 2
\f[I]unlock_time\f[R] - unsigned int; Number of blocks until transfer is
safely spendable.
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_transfer_by_txid\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]transfer\[dq]: {
      \[dq]address\[dq]: \[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],
      \[dq]amount\[dq]: 300000000000,
      \[dq]confirmations\[dq]: 1,
      \[dq]destinations\[dq]: [{
        \[dq]address\[dq]: \[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq],
        \[dq]amount\[dq]: 100000000000
      },{
        \[dq]address\[dq]: \[dq]77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\[dq],
        \[dq]amount\[dq]: 200000000000
      }],
      \[dq]double_spend_seen\[dq]: false,
      \[dq]fee\[dq]: 21650200000,
      \[dq]height\[dq]: 153624,
      \[dq]note\[dq]: \[dq]\[dq],
      \[dq]payment_id\[dq]: \[dq]0000000000000000\[dq],
      \[dq]subaddr_index\[dq]: {
        \[dq]major\[dq]: 0,
        \[dq]minor\[dq]: 0
      },
      \[dq]suggested_confirmations_threshold\[dq]: 1,
      \[dq]timestamp\[dq]: 1535918400,
      \[dq]txid\[dq]: \[dq]c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\[dq],
      \[dq]type\[dq]: \[dq]out\[dq],
      \[dq]unlock_time\[dq]: 0
    }
  }
}
\f[R]
.fi
.SS \f[B]get_transfers\f[R]
.PP
Returns a list of transfers.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]in\f[R] - boolean; (Optional) Include incoming transfers.
.IP \[bu] 2
\f[I]out\f[R] - boolean; (Optional) Include outgoing transfers.
.IP \[bu] 2
\f[I]pending\f[R] - boolean; (Optional) Include pending transfers.
.IP \[bu] 2
\f[I]failed\f[R] - boolean; (Optional) Include failed transfers.
.IP \[bu] 2
\f[I]pool\f[R] - boolean; (Optional) Include transfers from the
daemon\[cq]s transaction pool.
.IP \[bu] 2
\f[I]filter_by_height\f[R] - boolean; (Optional) Filter transfers by
block height.
.IP \[bu] 2
\f[I]min_height\f[R] - unsigned int; (Optional) Minimum block height to
scan for transfers, if filtering by height is enabled.
.IP \[bu] 2
\f[I]max_height\f[R] - unsigned int; (Optional) Maximum block height to
scan for transfers, if filtering by height is enabled (defaults to max
block height).
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; (Optional) Index of the account
to query for transfers.
(defaults to 0)
.IP \[bu] 2
\f[I]subaddr_indices\f[R] - array of unsigned int; (Optional) List of
subaddress indices to query for transfers.
(defaults to 0)
.PP
Outputs:
.IP \[bu] 2
\f[I]in\f[R] array of transfers:
.RS 2
.IP \[bu] 2
\f[I]address\f[R] - string; Public address of the transfer.
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount transferred.
.IP \[bu] 2
\f[I]confirmations\f[R] - unsigned int; Number of block mined since the
block containing this transaction (or block height at which the
transaction should be added to a block if not yet confirmed).
.IP \[bu] 2
\f[I]double_spend_seen\f[R] - boolean; True if the key image(s) for the
transfer have been seen before.
.IP \[bu] 2
\f[I]fee\f[R] - unsigned int; Transaction fee for this transfer.
.IP \[bu] 2
\f[I]height\f[R] - unsigned int; Height of the first block that
confirmed this transfer (0 if not mined yet).
.IP \[bu] 2
\f[I]note\f[R] - string; Note about this transfer.
.IP \[bu] 2
\f[I]payment_id\f[R] - string; Payment ID for this transfer.
.IP \[bu] 2
\f[I]subaddr_index\f[R] - JSON object containing the major & minor
subaddress index:
.RS 2
.IP \[bu] 2
\f[I]major\f[R] - unsigned int; Account index for the subaddress.
.IP \[bu] 2
\f[I]minor\f[R] - unsigned int; Index of the subaddress under the
account.
.RE
.IP \[bu] 2
\f[I]suggested_confirmations_threshold\f[R] - unsigned int; Estimation
of the confirmations needed for the transaction to be included in a
block.
.IP \[bu] 2
\f[I]timestamp\f[R] - unsigned int; POSIX timestamp for when this
transfer was first confirmed in a block (or timestamp submission if not
mined yet).
.IP \[bu] 2
\f[I]txid\f[R] - string; Transaction ID for this transfer.
.IP \[bu] 2
\f[I]type\f[R] - string; Transfer type: \[lq]in\[rq]
.IP \[bu] 2
\f[I]unlock_time\f[R] - unsigned int; Number of blocks until transfer is
safely spendable.
.RE
.IP \[bu] 2
\f[I]out\f[R] array of transfers (see above).
.IP \[bu] 2
\f[I]pending\f[R] array of transfers (see above).
.IP \[bu] 2
\f[I]failed\f[R] array of transfers (see above).
.IP \[bu] 2
\f[I]pool\f[R] array of transfers (see above).
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_transfers\[dq],\[dq]params\[dq]:{\[dq]in\[dq]:true,\[dq]account_index\[dq]:1}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]in\[dq]: [{
      \[dq]address\[dq]: \[dq]77Vx9cs1VPicFndSVgYUvTdLCJEZw9h81hXLMYsjBCXSJfUehLa9TDW3Ffh45SQa7xb6dUs18mpNxfUhQGqfwXPSMrvKhVp\[dq],
      \[dq]amount\[dq]: 200000000000,
      \[dq]confirmations\[dq]: 1,
      \[dq]double_spend_seen\[dq]: false,
      \[dq]fee\[dq]: 21650200000,
      \[dq]height\[dq]: 153624,
      \[dq]note\[dq]: \[dq]\[dq],
      \[dq]payment_id\[dq]: \[dq]0000000000000000\[dq],
      \[dq]subaddr_index\[dq]: {
        \[dq]major\[dq]: 1,
        \[dq]minor\[dq]: 0
      },
      \[dq]suggested_confirmations_threshold\[dq]: 1,
      \[dq]timestamp\[dq]: 1535918400,
      \[dq]txid\[dq]: \[dq]c36258a276018c3a4bc1f195a7fb530f50cd63a4fa765fb7c6f7f49fc051762a\[dq],
      \[dq]type\[dq]: \[dq]in\[dq],
      \[dq]unlock_time\[dq]: 0
    }]
  }
}
\f[R]
.fi
.SS \f[B]get_tx_key\f[R]
.PP
Get transaction secret key from transaction id.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txid\f[R] - string; transaction id.
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_key\f[R] - string; transaction secret key.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_tx_key\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]tx_key\[dq]: \[dq]feba662cf8fb6d0d0da18fc9b70ab28e01cc76311278fdd7fe7ab16360762b06\[dq]
  }
}
\f[R]
.fi
.SS \f[B]get_tx_notes\f[R]
.PP
Get string notes for transactions.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txids\f[R] - array of string; transaction ids
.PP
Outputs:
.IP \[bu] 2
\f[I]notes\f[R] - array of string; notes for the transactions
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_tx_notes\[dq],\[dq]params\[dq]:{\[dq]txids\[dq]:[\[dq]3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\[dq]]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]notes\[dq]: [\[dq]This is an example\[dq]]
  }
}
\f[R]
.fi
.SS \f[B]get_tx_proof\f[R]
.PP
Get transaction signature to prove it.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txid\f[R] - string; transaction id.
.IP \[bu] 2
\f[I]address\f[R] - string; destination public address of the
transaction.
.IP \[bu] 2
\f[I]message\f[R] - string; (Optional) add a message to the signature to
further authenticate the prooving process.
.PP
Outputs:
.IP \[bu] 2
\f[I]signature\f[R] - string; transaction signature.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_tx_proof\[dq],\[dq]params\[dq]:{\[dq]txid\[dq]:\[dq]19d5089f9469db3d90aca9024dfcb17ce94b948300101c8345a5e9f7257353be\[dq],\[dq]address\[dq]:\[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq],\[dq]message\[dq]:\[dq]this is my transaction\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]signature\[dq]: \[dq]InProofV13vqBCT6dpSAXkypZmSEMPGVnNRFDX2vscUYeVS4WnSVnV5BwLs31T9q6Etfj9Wts6tAxSAS4gkMeSYzzLS7Gt4vvCSQRh9niGJMUDJsB5hTzb2XJiCkUzWkkcjLFBBRVD5QZ\[dq]
  }
}
\f[R]
.fi
.SS \f[B]get_version\f[R]
.PP
Get RPC version Major & Minor integer-format, where Major is the first
16 bits and Minor the last 16 bits.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]version\f[R] - unsigned int; RPC version, formatted with
\f[V]Major * 2\[ha]16 + Minor\f[R](Major encoded over the first 16 bits,
and Minor over the last 16 bits).
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]get_version\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]version\[dq]: 65539
  }
}
\f[R]
.fi
.SS \f[B]import_key_images\f[R]
.PP
Import signed key images list and verify their spent status.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]signed_key_images\f[R] - array of signed key images:
.RS 2
.IP \[bu] 2
\f[I]key_image\f[R] - string;
.IP \[bu] 2
\f[I]signature\f[R] - string;
.RE
.PP
Outputs:
.IP \[bu] 2
\f[I]height\f[R] - unsigned int;
.IP \[bu] 2
\f[I]spent\f[R] - unsigned int; Amount (in atomic units) spent from
those key images.
.IP \[bu] 2
\f[I]unspent\f[R] - unsigned int; Amount (in atomic units) still
available from those key images.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]import_key_images\[dq], \[dq]params\[dq]:{\[dq]signed_key_images\[dq]:[{\[dq]key_image\[dq]:\[dq]cd35239b72a35e26a57ed17400c0b66944a55de9d5bda0f21190fed17f8ea876\[dq],\[dq]signature\[dq]:\[dq]c9d736869355da2538ab4af188279f84138c958edbae3c5caf388a63cd8e780b8c5a1aed850bd79657df659422c463608ea4e0c730ba9b662c906ae933816d00\[dq]},{\[dq]key_image\[dq]:\[dq]65158a8ee5a3b32009b85a307d85b375175870e560e08de313531c7dbbe6fc19\[dq],\[dq]signature\[dq]:\[dq]c96e40d09dfc45cfc5ed0b76bfd7ca793469588bb0cf2b4d7b45ef23d40fd4036057b397828062e31700dc0c2da364f50cd142295a8405b9fe97418b4b745d0c\[dq]}]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]height\[dq]: 76428,
    \[dq]spent\[dq]: 62708953408711,
    \[dq]unspent\[dq]: 0
  }
}
\f[R]
.fi
.SS \f[B]import_multisig_info\f[R]
.PP
Import multisig info from other participants.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]info\f[R] - array of string; List of multisig info in hex format
from other participants.
.PP
Outputs:
.IP \[bu] 2
\f[I]n_outputs\f[R] - unsigned int; Number of outputs signed with those
multisig info.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]import_multisig_info\[dq],\[dq]params\[dq]:{\[dq]info\[dq]:[\[dq]...multisig_info...\[dq]]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]n_outputs\[dq]: 35
  }
}
\f[R]
.fi
.SS \f[B]import_outputs\f[R]
.PP
Import outputs in hex format.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]outputs_data_hex\f[R] - string; wallet outputs in hex format.
.PP
Outputs:
.IP \[bu] 2
\f[I]num_imported\f[R] - unsigned int; number of outputs imported.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]import_outputs\[dq],\[dq]params\[dq]:{\[dq]outputs_data_hex\[dq]:\[dq]...outputs...\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]num_imported\[dq]: 6400
  }
}
\f[R]
.fi
.SS \f[B]incoming_transfers\f[R]
.PP
Return a list of incoming transfers to the wallet.
.PP
Inputs:
.IP \[bu] 2
\f[I]transfer_type\f[R] - string; \[lq]all\[rq]: all the transfers,
\[lq]available\[rq]: only transfers which are not yet spent, OR
\[lq]unavailable\[rq]: only transfers which are already spent.
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; (Optional) Return transfers for
this account.
(defaults to 0)
.IP \[bu] 2
\f[I]subaddr_indices\f[R] - array of unsigned int; (Optional) Return
transfers sent to these subaddresses.
.IP \[bu] 2
\f[I]verbose\f[R] - boolean; (Optional) Enable verbose output, return
key image if true.
.PP
Outputs:
.IP \[bu] 2
\f[I]transfers\f[R] - list of:
.RS 2
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount of this transfer.
.IP \[bu] 2
\f[I]global_index\f[R] - unsigned int; Mostly internal use, can be
ignored by most users.
.IP \[bu] 2
\f[I]key_image\f[R] - string; Key image for the incoming transfer\[cq]s
unspent output (empty unless verbose is true).
.IP \[bu] 2
\f[I]spent\f[R] - boolean; Indicates if this transfer has been spent.
.IP \[bu] 2
\f[I]subaddr_index\f[R] - unsigned int; Subaddress index for incoming
transfer.
.IP \[bu] 2
\f[I]tx_hash\f[R] - string; Several incoming transfers may share the
same hash if they were in the same transaction.
.IP \[bu] 2
\f[I]tx_size\f[R] - unsigned int; Size of transaction in bytes.
.RE
.PP
Example, get all transfers:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]incoming_transfers\[dq],\[dq]params\[dq]:{\[dq]transfer_type\[dq]:\[dq]all\[dq],\[dq]account_index\[dq]:0,\[dq]subaddr_indices\[dq]:[3],\[dq]verbose\[dq]:true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]transfers\[dq]: [{
      \[dq]amount\[dq]: 60000000000000,
      \[dq]global_index\[dq]: 122405,
      \[dq]key_image\[dq]: \[dq]768f5144777eb23477ab7acf83562581d690abaf98ca897c03a9d2b900eb479b\[dq],
      \[dq]spent\[dq]: true,
      \[dq]subaddr_index\[dq]: 3,
      \[dq]tx_hash\[dq]: \[dq]f53401f21c6a43e44d5dd7a90eba5cf580012ad0e15d050059136f8a0da34f6b\[dq],
      \[dq]tx_size\[dq]: 159
    },{
      \[dq]amount\[dq]: 27126892247503,
      \[dq]global_index\[dq]: 594994,
      \[dq]key_image\[dq]: \[dq]7e561394806afd1be61980cc3431f6ef3569fa9151cd8d234f8ec13aa145695e\[dq],
      \[dq]spent\[dq]: false,
      \[dq]subaddr_index\[dq]: 3,
      \[dq]tx_hash\[dq]: \[dq]106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\[dq],
      \[dq]tx_size\[dq]: 157
    },{
      \[dq]amount\[dq]: 27169374733655,
      \[dq]global_index\[dq]: 594997,
      \[dq]key_image\[dq]: \[dq]e76c0a3bfeaae35e4173712f782eb34011198e26b990225b71aa787c8ba8a157\[dq],
      \[dq]spent\[dq]: false,
      \[dq]subaddr_index\[dq]: 3,
      \[dq]tx_hash\[dq]: \[dq]0bd959b59117ee1254bd8e5aa8e77ec04ef744144a1ffb2d5c1eb9380a719621\[dq],
      \[dq]tx_size\[dq]: 158
    }]
  }
}
\f[R]
.fi
.PP
Example, get available transfers:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]incoming_transfers\[dq],\[dq]params\[dq]:{\[dq]transfer_type\[dq]:\[dq]available\[dq],\[dq]account_index\[dq]:0,\[dq]subaddr_indices\[dq]:[3],\[dq]verbose\[dq]:true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]transfers\[dq]: [{
      \[dq]amount\[dq]: 27126892247503,
      \[dq]global_index\[dq]: 594994,
      \[dq]key_image\[dq]: \[dq]7e561394806afd1be61980cc3431f6ef3569fa9151cd8d234f8ec13aa145695e\[dq],
      \[dq]spent\[dq]: false,
      \[dq]subaddr_index\[dq]: 3,
      \[dq]tx_hash\[dq]: \[dq]106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\[dq],
      \[dq]tx_size\[dq]: 157
    },{
      \[dq]amount\[dq]: 27169374733655,
      \[dq]global_index\[dq]: 594997,
      \[dq]key_image\[dq]: \[dq]e76c0a3bfeaae35e4173712f782eb34011198e26b990225b71aa787c8ba8a157\[dq],
      \[dq]spent\[dq]: false,
      \[dq]subaddr_index\[dq]: 3,
      \[dq]tx_hash\[dq]: \[dq]0bd959b59117ee1254bd8e5aa8e77ec04ef744144a1ffb2d5c1eb9380a719621\[dq],
      \[dq]tx_size\[dq]: 158
    }]
  }
}
\f[R]
.fi
.PP
Example, get unavailable transfers:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]incoming_transfers\[dq],\[dq]params\[dq]:{\[dq]transfer_type\[dq]:\[dq]unavailable\[dq],\[dq]account_index\[dq]:0,\[dq]subaddr_indices\[dq]:[3],\[dq]verbose\[dq]:true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
\[dq]id\[dq]: \[dq]0\[dq],
\[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
\[dq]result\[dq]: {
  \[dq]transfers\[dq]: [{
    \[dq]amount\[dq]: 60000000000000,
    \[dq]global_index\[dq]: 122405,
    \[dq]key_image\[dq]: \[dq]768f5144777eb23477ab7acf83562581d690abaf98ca897c03a9d2b900eb479b\[dq],
    \[dq]spent\[dq]: true,
    \[dq]subaddr_index\[dq]: 3,
    \[dq]tx_hash\[dq]: \[dq]f53401f21c6a43e44d5dd7a90eba5cf580012ad0e15d050059136f8a0da34f6b\[dq],
    \[dq]tx_size\[dq]: 159
  }]
}
}
\f[R]
.fi
.SS \f[B]is_multisig\f[R]
.PP
Check if a wallet is a multisig one.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]multisig\f[R] - boolean; States if the wallet is multisig
.IP \[bu] 2
\f[I]ready\f[R] - boolean;
.IP \[bu] 2
\f[I]threshold\f[R] - unsigned int; Amount of signature needed to sign a
transfer.
.IP \[bu] 2
\f[I]total\f[R] - unsigned int; Total amount of signature in the
multisig wallet.
.PP
Example for a non-multisig wallet:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]is_multisig\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]multisig\[dq]: false,
    \[dq]ready\[dq]: false,
    \[dq]threshold\[dq]: 0,
    \[dq]total\[dq]: 0
  }
}
\f[R]
.fi
.PP
Example for a multisig wallet:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]is_multisig\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]                  {
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]multisig\[dq]: true,
    \[dq]ready\[dq]: true,
    \[dq]threshold\[dq]: 2,
    \[dq]total\[dq]: 2
  }
}
\f[R]
.fi
.SS \f[B]label_account\f[R]
.PP
Label an account.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; Apply label to account at this
index.
.IP \[bu] 2
\f[I]label\f[R] - string; Label for the account.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]label_account\[dq],\[dq]params\[dq]:{\[dq]account_index\[dq]:0,\[dq]label\[dq]:\[dq]Primary account\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]account_tags\[dq]: [{
      \[dq]accounts\[dq]: [0,1],
      \[dq]label\[dq]: \[dq]\[dq],
      \[dq]tag\[dq]: \[dq]myTag\[dq]
    }]
  }
}
\f[R]
.fi
.SS \f[B]label_address\f[R]
.PP
Label an address.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]index\f[R] - subaddress index; JSON Object containing the major &
minor address index:
.RS 2
.IP \[bu] 2
\f[I]major\f[R] - unsigned int; Account index for the subaddress.
.IP \[bu] 2
\f[I]minor\f[R] - unsigned int; Index of the subaddress in the account.
.RE
.IP \[bu] 2
\f[I]label\f[R] - string; Label for the address.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]label_address\[dq],\[dq]params\[dq]:{\[dq]index\[dq]:{\[dq]major\[dq]:0,\[dq]minor\[dq]:5},\[dq]label\[dq]:\[dq]myLabel\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]make_integrated_address\f[R]
.PP
Make an integrated address from the wallet address and a payment id.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]standard_address\f[R] - string; (Optional, defaults to primary
address) Destination public address.
.IP \[bu] 2
\f[I]payment_id\f[R] - string; (Optional, defaults to a random ID) 16
characters hex encoded.
.PP
Outputs:
.IP \[bu] 2
\f[I]integrated_address\f[R] - string
.IP \[bu] 2
\f[I]payment_id\f[R] - string; hex encoded;
.PP
Example (Payment ID is empty, use a random ID):
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]make_integrated_address\[dq],\[dq]params\[dq]:{\[dq]standard_address\[dq]:\[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]integrated_address\[dq]: \[dq]5F38Rw9HKeaLQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZXCkbHUXdPHyiUeRyokn\[dq],
    \[dq]payment_id\[dq]: \[dq]420fa29b2d9a49f5\[dq]
  }
}
\f[R]
.fi
.SS \f[B]make_multisig\f[R]
.PP
Make a wallet multisig by importing peers multisig string.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]multisig_info\f[R] - array of string; List of multisig string from
peers.
.IP \[bu] 2
\f[I]threshold\f[R] - unsigned int; Amount of signatures needed to sign
a transfer.
Must be less or equal than the amount of signature in
\f[V]multisig_info\f[R].
.IP \[bu] 2
\f[I]password\f[R] - string; Wallet password
.PP
Outputs:
.IP \[bu] 2
\f[I]address\f[R] - string; multisig wallet address.
.IP \[bu] 2
\f[I]multisig_info\f[R] - string; Multisig string to share with peers to
create the multisig wallet (extra step for N-1/N wallets).
.PP
Example for 2/2 Multisig Wallet:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]make_multisig\[dq],\[dq]params\[dq]:{\[dq]multisig_info\[dq]:[\[dq]MultisigV1K4tGGe8QirZdHgTYoBZMumSug97fdDyM3Z63M3ZY5VXvAdoZvx16HJzPCP4Rp2ABMKUqLD2a74ugMdBfrVpKt4BwD8qCL5aZLrsYWoHiA7JJwDESuhsC3eF8QC9UMvxLXEMsMVh16o98GnKRYz1HCKXrAEWfcrCHyz3bLW1Pdggyowop\[dq]],\[dq]threshold\[dq]:2}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]address\[dq]: \[dq]55SoZTKH7D39drxfgT62k8T4adVFjmDLUXnbzEKYf1MoYwnmTNKKaqGfxm4sqeKCHXQ5up7PVxrkoeRzXu83d8xYURouMod\[dq],
    \[dq]multisig_info\[dq]: \[dq]\[dq]
  }
}
\f[R]
.fi
.PP
Example for 2/3 Multisig Wallet:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]make_multisig\[dq],\[dq]params\[dq]:{\[dq]multisig_info\[dq]:[\[dq]MultisigV1MTVm4DZAdJw1PyVutpSy8Q4WisZBCFRAaZY7hhQnMwr5AZ4swzThyaSiVVQM5FHj1JQi3zPKhQ4k81BZkPSEaFjwRJtbfqfJcVvCqRnmBVcWVxhnihX5s8fZWBCjKrzT3CS95spG4dzNzJSUcjheAkLzCpVmSzGtgwMhAS3Vuz9Pas24\[dq],\[dq]MultisigV1TEx58ycKCd6ADCfxF8hALpcdSRAkhZTi1bu4Rs6FdRC98EdB1LY7TAkMxasM55khFgcxrSXivaSr5FCMyJGHmojm1eE4HpGWPeZKv6cgCTThRzC4u6bkkSoFQdbzWN92yn1XEjuP2XQrGHk81mG2LMeyB51MWKJAVF99Pg9mX2BpmYFj\[dq]],\[dq]threshold\[dq]:2}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]address\[dq]: \[dq]51sLpF8fWaK1111111111111111111111111111111111ABVbHNf1JFWJyFp5YZgZRQ44RiviJi1sPHgLVMbckRsDkTRgKS\[dq],
    \[dq]multisig_info\[dq]: \[dq]MultisigxV18jCaYAQQvzCMUJaAWMCaAbAoHpAD6WPmYDmLtBtazD654E8RWkLaGRf29fJ3stU471MELKxwufNYeigP7LoE4tn2Sscwn5g7PyCfcBc1V4ffRHY3Kxqq6VocSCUTncpVeUskaDKuTAWtdB9VTBGW7iG1cd7Zm1dYgur3CiemkGjRUAj9bL3xTEuyaKGYSDhtpFZFp99HQX57EawhiRHk3qq4hjWX\[dq]
  }
}
\f[R]
.fi
.SS \f[B]make_uri\f[R]
.PP
Create a payment URI using the official URI spec.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]address\f[R] - string; Wallet address
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; (optional) the integer amount to
receive, in \f[B]atomic\f[R]units
.IP \[bu] 2
\f[I]payment_id\f[R] - string; (optional) 16 or 64 character hexadecimal
payment id
.IP \[bu] 2
\f[I]recipient_name\f[R] - string; (optional) name of the payment
recipient
.IP \[bu] 2
\f[I]tx_description\f[R] - string; (optional) Description of the reason
for the tx
.PP
Outputs:
.IP \[bu] 2
\f[I]uri\f[R] - string; This contains all the payment input information
as a properly formatted payment URI
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]make_uri\[dq],\[dq]params\[dq]:{\[dq]address\[dq]:\[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],\[dq]amount\[dq]:10,\[dq]payment_id\[dq]:\[dq]420fa29b2d9a49f5\[dq],\[dq]tx_description\[dq]:\[dq]Testing out the make_uri function.\[dq],\[dq]recipient_name\[dq]:\[dq]el00ruobuob Stagenet wallet\[dq]}}\[aq]  -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]uri\[dq]: \[dq]monero:55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt?tx_payment_id=420fa29b2d9a49f5&tx_amount=0.000000000010&recipient_name=el00ruobuob%20Stagenet%20wallet&tx_description=Testing%20out%20the%20make_uri%20function.\[dq]
  }
}
\f[R]
.fi
.SS \f[B]open_wallet\f[R]
.PP
Open a wallet.
You need to have set the argument \[lq]\[en]wallet-dir\[rq] when
launching monero-wallet-rpc to make this work.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]filename\f[R] - string; wallet name stored in \[en]wallet-dir.
.IP \[bu] 2
\f[I]password\f[R] - string; (Optional) only needed if the wallet has a
password defined.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]open_wallet\[dq],\[dq]params\[dq]:{\[dq]filename\[dq]:\[dq]mytestwallet\[dq],\[dq]password\[dq]:\[dq]mytestpassword\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]parse_uri\f[R]
.PP
Parse a payment URI to get payment information.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]uri\f[R] - string; This contains all the payment input information
as a properly formatted payment URI
.PP
Outputs:
.IP \[bu] 2
\f[I]uri\f[R] - JSON object containing payment information:
.RS 2
.IP \[bu] 2
\f[I]address\f[R] - string; Wallet address
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Decimal amount to receive, in
\f[B]coin\f[R] units (0 if not provided)
.IP \[bu] 2
\f[I]payment_id\f[R] - string; 16 or 64 character hexadecimal payment id
(empty if not provided)
.IP \[bu] 2
\f[I]recipient_name\f[R] - string; Name of the payment recipient (empty
if not provided)
.IP \[bu] 2
\f[I]tx_description\f[R] - string; Description of the reason for the tx
(empty if not provided)
.RE
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]parse_uri\[dq],\[dq]params\[dq]:{\[dq]uri\[dq]:\[dq]monero:55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt?tx_payment_id=420fa29b2d9a49f5&tx_amount=0.000000000010&recipient_name=el00ruobuob%20Stagenet%20wallet&tx_description=Testing%20out%20the%20make_uri%20function.\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]uri\[dq]: {
      \[dq]address\[dq]: \[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],
      \[dq]amount\[dq]: 10,
      \[dq]payment_id\[dq]: \[dq]420fa29b2d9a49f5\[dq],
      \[dq]recipient_name\[dq]: \[dq]el00ruobuob Stagenet wallet\[dq],
      \[dq]tx_description\[dq]: \[dq]Testing out the make_uri function.\[dq]
    }
  }
}
\f[R]
.fi
.SS \f[B]prepare_multisig\f[R]
.PP
Prepare a wallet for multisig by generating a multisig string to share
with peers.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]multisig_info\f[R] - string; Multisig string to share with peers to
create the multisig wallet.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]prepare_multisig\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]multisig_info\[dq]: \[dq]MultisigV1BFdxQ653cQHB8wsj9WJQd2VdnjxK89g5M94dKPBNw22reJnyJYKrz6rJeXdjFwJ3Mz6n4qNQLd6eqUZKLiNzJFi3UPNVcTjtkG2aeSys9sYkvYYKMZ7chCxvoEXVgm74KKUcUu4V8xveCBFadFuZs8shnxBWHbcwFr5AziLr2mE7KHJT\[dq]
  }
}
\f[R]
.fi
.SS \f[B]query_key\f[R]
.PP
Return the spend or view private key.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]key_type\f[R] - string; Which key to retrieve: \[lq]mnemonic\[rq] -
the mnemonic seed (older wallets do not have one) OR \[lq]view_key\[rq]
- the view key
.PP
Outputs:
.IP \[bu] 2
\f[I]key\f[R] - string; The view key will be hex encoded, while the
mnemonic will be a string of words.
.PP
Example (Query view key):
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]query_key\[dq],\[dq]params\[dq]:{\[dq]key_type\[dq]:\[dq]view_key\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]key\[dq]: \[dq]0a1a38f6d246e894600a3e27238a064bf5e8d91801df47a17107596b1378e501\[dq]
  }
}
\f[R]
.fi
.PP
Example (Query mnemonic key):
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]query_key\[dq],\[dq]params\[dq]:{\[dq]key_type\[dq]:\[dq]mnemonic\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]key\[dq]: \[dq]vocal either anvil films dolphin zeal bacon cuisine quote syndrome rejoices envy okay pancakes tulips lair greater petals organs enmity dedicated oust thwart tomorrow tomorrow\[dq]
  }
}
\f[R]
.fi
.SS \f[B]refresh\f[R]
.PP
Refresh a wallet after openning.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]start_height\f[R] - unsigned int; (Optional) The block height from
which to start refreshing.
.PP
Outputs:
.IP \[bu] 2
\f[I]blocks_fetched\f[R] - unsigned int; Number of new blocks scanned.
.IP \[bu] 2
\f[I]received_money\f[R] - boolean; States if transactions to the wallet
have been found in the blocks.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]refresh\[dq],\[dq]params\[dq]:{\[dq]start_height\[dq]:100000}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]blocks_fetched\[dq]: 24,
    \[dq]received_money\[dq]: true
  }
}
\f[R]
.fi
.SS \f[B]relay_tx\f[R]
.PP
Relay a transaction previously created with
\f[V]\[dq]do_not_relay\[dq]:true\f[R].
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]hex\f[R] - string; transaction metadata returned from a
\f[V]transfer\f[R] method with \f[V]get_tx_metadata\f[R] set to
\f[V]true\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_hash\f[R] - String for the publically searchable transaction
hash.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]relay_tx\[dq],\[dq]params\[dq]:{\[dq]hex\[dq]:\[dq]...tx_metadata...\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]tx_hash\[dq]: \[dq]1c42dcc5672bb09bccf33fb1e9ab4a498af59a6dbd33b3d0cfb289b9e0e25fa5\[dq]
  }
}
\f[R]
.fi
.SS \f[B]rescan_blockchain\f[R]
.PP
Rescan the blockchain from scratch, losing any information which can not
be recovered from the blockchain itself.
This includes destination addresses, tx secret keys, tx notes, etc.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]rescan_blockchain\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]rescan_spent\f[R]
.PP
Rescan the blockchain for spent outputs.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]rescan_spent\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]

{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]set_account_tag_description\f[R]
.PP
Set description for an account tag.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]tag\f[R] - string; Set a description for this tag.
.IP \[bu] 2
\f[I]description\f[R] - string; Description for the tag.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]set_account_tag_description\[dq],\[dq]params\[dq]:{\[dq]tag\[dq]:\[dq]myTag\[dq],\[dq]description\[dq]:\[dq]Test tag\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]set_attribute\f[R]
.PP
Set arbitrary attribute.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]key\f[R] - string; attribute name
.IP \[bu] 2
\f[I]value\f[R] - string; attribute value
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]set_attribute\[dq],\[dq]params\[dq]:{\[dq]key\[dq]:\[dq]my_attribute\[dq],\[dq]value\[dq]:\[dq]my_value\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]set_tx_notes\f[R]
.PP
Set arbitrary string notes for transactions.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]txids\f[R] - array of string; transaction ids
.IP \[bu] 2
\f[I]notes\f[R] - array of string; notes for the transactions
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]set_tx_notes\[dq],\[dq]params\[dq]:{\[dq]txids\[dq]:[\[dq]3292e83ad28fc1cc7bc26dbd38862308f4588680fbf93eae3e803cddd1bd614f\[dq]],\[dq]notes\[dq]:[\[dq]This is an example\[dq]]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]sign\f[R]
.PP
Sign a string.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]data\f[R] - string; Anything you need to sign.
.PP
Outputs:
.IP \[bu] 2
\f[I]signature\f[R] - string; Signature generated against the
\[lq]data\[rq] and the account public address.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]sign\[dq],\[dq]params\[dq]:{\[dq]data\[dq]:\[dq]This is sample data to be signed\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]signature\[dq]: \[dq]SigV14K6G151gycjiGxjQ74tKX6A2LwwghvuHjcDeuRFQio5LS6Gb27BNxjYQY1dPuUvXkEbGQUkiHSVLPj4nJAHRrrw3\[dq]
  }
}
\f[R]
.fi
.SS \f[B]sign_multisig\f[R]
.PP
Sign a transaction in multisig.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]tx_data_hex\f[R] - string; Multisig transaction in hex format, as
returned by \f[V]transfer\f[R] under \f[V]multisig_txset\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_data_hex\f[R] - string; Multisig transaction in hex format.
.IP \[bu] 2
\f[I]tx_hash_list\f[R] - array of string; List of transaction Hash.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]sign_multisig\[dq],\[dq]params\[dq]:{\[dq]tx_data_hex\[dq]:\[dq]...multisig_txset...\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]tx_data_hex\[dq]: \[dq]...multisig_txset...\[dq],
    \[dq]tx_hash_list\[dq]: [\[dq]4996091b61c1be112c1097fd5e97d8ff8b28f0e5e62e1137a8c831bacf034f2d\[dq]]
  }
}
\f[R]
.fi
.SS \f[B]sign_transfer\f[R]
.PP
Sign a transaction created on a read-only wallet (in cold-signing
process)
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]unsigned_txset\f[R] - string.
Set of unsigned tx returned by \[lq]transfer\[rq] or
\[lq]transfer_split\[rq] methods.
.IP \[bu] 2
\f[I]export_raw\f[R] - boolean; (Optional) If true, return the raw
transaction data.
(Defaults to false)
.PP
Outputs:
.IP \[bu] 2
\f[I]signed_txset\f[R] - string.
Set of signed tx to be used for submitting transfer.
.IP \[bu] 2
\f[I]tx_hash_list\f[R] - array of: string.
The tx hashes of every transaction.
.IP \[bu] 2
\f[I]tx_raw_list\f[R] - array of: string.
The tx raw data of every transaction.
.PP
In the example below, we first generate an unsigned_txset on a read only
wallet before signing it:
.PP
Generate unsigned_txset using the above \[lq]transfer\[rq] method on
read-only wallet:
.IP
.nf
\f[C]
curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]transfer\[dq],\[dq]params\[dq]:{\[dq]destinations\[dq]:[{\[dq]amount\[dq]:1000000000000,\[dq]address\[dq]:\[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq]}],\[dq]account_index\[dq]:0,\[dq]subaddr_indices\[dq]:[0],\[dq]priority\[dq]:0,\[dq]ring_size\[dq]:7,\[dq]do_not_relay\[dq]:true,\[dq]get_tx_hex\[dq]:true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]amount\[dq]: 1000000000000,
    \[dq]fee\[dq]: 15202740000,
    \[dq]multisig_txset\[dq]: \[dq]\[dq],
    \[dq]tx_blob\[dq]: \[dq]...long_hex...\[dq],
    \[dq]tx_hash\[dq]: \[dq]c648ba0a049e5ce4ec21361dbf6e4b21eac0f828eea9090215de86c76b31d0a4\[dq],
    \[dq]tx_key\[dq]: \[dq]\[dq],
    \[dq]tx_metadata\[dq]: \[dq]\[dq],
    \[dq]unsigned_txset\[dq]: \[dq]...long_hex...\[dq]
  }
}
\f[R]
.fi
.PP
Sign tx using the previously generated unsigned_txset
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]sign_transfer\[dq],\[dq]params\[dq]:{\[dq]unsigned_txset\[dq]:...long_hex...\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]signed_txset\[dq]: \[dq]...long_hex...\[dq],
    \[dq]tx_hash_list\[dq]: [\[dq]ff2e2d49fbfb1c9a55754f786576e171c8bf21b463a74438df604b7fa6cebc6d\[dq]]
  }
}
\f[R]
.fi
.SS \f[B]split_integrated_address\f[R]
.PP
Retrieve the standard address and payment id corresponding to an
integrated address.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]integrated_address\f[R] - string
.PP
Outputs:
.IP \[bu] 2
\f[I]is_subaddress\f[R] - boolean; States if the address is a subaddress
.IP \[bu] 2
\f[I]payment\f[R] - string; hex encoded
.IP \[bu] 2
\f[I]standard_address\f[R] - string
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]split_integrated_address\[dq],\[dq]params\[dq]:{\[dq]integrated_address\[dq]: \[dq]5F38Rw9HKeaLQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZXCkbHUXdPHyiUeRyokn\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]is_subaddress\[dq]: false,
    \[dq]payment_id\[dq]: \[dq]420fa29b2d9a49f5\[dq],
    \[dq]standard_address\[dq]: \[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq]
  }
}
\f[R]
.fi
.SS \f[B]start_mining\f[R]
.PP
Start mining in the Monero daemon.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]threads_count\f[R] - unsigned int; Number of threads created for
mining.
.IP \[bu] 2
\f[I]do_background_mining\f[R] - boolean; Allow to start the miner in
smart
mining (https://ww.getmonero.org/resources/moneropedia/smartmining.html)mode.
.IP \[bu] 2
\f[I]ignore_battery\f[R] - boolean; Ignore battery status (for smart
mining (https://ww.getmonero.org/resources/moneropedia/smartmining.html)
only)
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]start_mining\[dq],\[dq]params\[dq]:{\[dq]threads_count\[dq]:1,\[dq]do_background_mining\[dq]:true,\[dq]ignore_battery\[dq]:false}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]stop_mining\f[R]
.PP
Stop mining in the Monero daemon.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]stop_mining\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]stop_wallet\f[R]
.PP
Stops the wallet, storing the current state.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]stop_wallet\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]store\f[R]
.PP
Save the wallet file.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs: \f[I]None\f[R].
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]store\[dq]}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]submit_multisig\f[R]
.PP
Submit a signed multisig transaction.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]tx_data_hex\f[R] - string; Multisig transaction in hex format, as
returned by \f[V]sign_multisig\f[R] under \f[V]tx_data_hex\f[R].
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_hash_list\f[R] - array of string; List of transaction Hash.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]submit_multisig\[dq],\[dq]params\[dq]:{\[dq]tx_data_hex\[dq]:\[dq]...tx_data_hex...\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]tx_hash_list\[dq]: [\[dq]4996091b61c1be112c1097fd5e97d8ff8b28f0e5e62e1137a8c831bacf034f2d\[dq]]
  }
}
\f[R]
.fi
.SS \f[B]submit_transfer\f[R]
.PP
Submit a previously signed transaction on a read-only wallet (in
cold-signing process).
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]tx_data_hex\f[R] - string; Set of signed tx returned by
\[lq]sign_transfer\[rq]
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_hash_list\f[R] - array of: string.
The tx hashes of every transaction.
.PP
In the example below, we submit the transfer using the signed_txset
generated above:
.IP
.nf
\f[C]
curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]submit_transfer\[dq],\[dq]params\[dq]:{\[dq]tx_data_hex\[dq]:...long_hex...\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]tx_hash_list\[dq]: [\[dq]40fad7c828bb383ac02648732f7afce9adc520ba5629e1f5d9c03f584ac53d74\[dq]]
  }
}
\f[R]
.fi
.SS \f[B]sweep_all\f[R]
.PP
Send all unlocked balance to an address.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]address\f[R] - string; Destination public address.
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; Sweep transactions from this
account.
.IP \[bu] 2
\f[I]subaddr_indices\f[R] - array of unsigned int; (Optional) Sweep from
this set of subaddresses in the account.
.IP \[bu] 2
\f[I]priority\f[R] - unsigned int; (Optional) Priority for sending the
sweep transfer, partially determines fee.
.IP \[bu] 2
\f[I]mixin\f[R] - unsigned int; Number of outputs from the blockchain to
mix with (0 means no mixing).
.IP \[bu] 2
\f[I]ring_size\f[R] - unsigned int; Sets ringsize to n (mixin + 1).
.IP \[bu] 2
\f[I]unlock_time\f[R] - unsigned int; Number of blocks before the monero
can be spent (0 to not add a lock).
.IP \[bu] 2
\f[I]payment_id\f[R] - string; (Optional) Random 32-byte/64-character
hex string to identify a transaction.
.IP \[bu] 2
\f[I]get_tx_keys\f[R] - boolean; (Optional) Return the transaction keys
after sending.
.IP \[bu] 2
\f[I]below_amount\f[R] - unsigned int; (Optional) Include outputs below
this amount.
.IP \[bu] 2
\f[I]do_not_relay\f[R] - boolean; (Optional) If true, do not relay this
sweep transfer.
(Defaults to false)
.IP \[bu] 2
\f[I]get_tx_hex\f[R] - boolean; (Optional) return the transactions as
hex encoded string.
(Defaults to false)
.IP \[bu] 2
\f[I]get_tx_metadata\f[R] - boolean; (Optional) return the transaction
metadata as a string.
(Defaults to false)
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_hash_list\f[R] - array of: string.
The tx hashes of every transaction.
.IP \[bu] 2
\f[I]tx_key_list\f[R] - array of: string.
The transaction keys for every transaction.
.IP \[bu] 2
\f[I]amount_list\f[R] - array of: integer.
The amount transferred for every transaction.
.IP \[bu] 2
\f[I]fee_list\f[R] - array of: integer.
The amount of fees paid for every transaction.
.IP \[bu] 2
\f[I]tx_blob_list\f[R] - array of: string.
The tx as hex string for every transaction.
.IP \[bu] 2
\f[I]tx_metadata_list\f[R] - array of: string.
List of transaction metadata needed to relay the transactions later.
.IP \[bu] 2
\f[I]multisig_txset\f[R] - string.
The set of signing keys used in a multisig transaction (empty for
non-multisig).
.IP \[bu] 2
\f[I]unsigned_txset\f[R] - string.
Set of unsigned tx for cold-signing purposes.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]sweep_all\[dq],\[dq]params\[dq]:{\[dq]address\[dq]:\[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],\[dq]subaddr_indices\[dq]:[4],\[dq]ring_size\[dq]:7,\[dq]unlock_time\[dq]:0,\[dq]get_tx_keys\[dq]:true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]amount_list\[dq]: [9985885770000],
    \[dq]fee_list\[dq]: [14114230000],
    \[dq]multisig_txset\[dq]: \[dq]\[dq],
    \[dq]tx_hash_list\[dq]: [\[dq]ab4b6b65cc8cd8c9dd317d0b90d97582d68d0aa1637b0065b05b61f9a66ea5c5\[dq]],
    \[dq]tx_key_list\[dq]: [\[dq]b9b4b39d3bb3062ddb85ec0266d4df39058f4c86077d99309f218ce4d76af607\[dq]],
    \[dq]unsigned_txset\[dq]: \[dq]\[dq]
  }
}
\f[R]
.fi
.SS \f[B]sweep_dust\f[R]
.PP
Send all dust outputs back to the wallet\[cq]s, to make them easier to
spend (and mix).
.PP
Alias: \f[I]sweep_unmixable\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]get_tx_keys\f[R] - boolean; (Optional) Return the transaction keys
after sending.
.IP \[bu] 2
\f[I]do_not_relay\f[R] - boolean; (Optional) If true, the newly created
transaction will not be relayed to the monero network.
(Defaults to false)
.IP \[bu] 2
\f[I]get_tx_hex\f[R] - boolean; (Optional) Return the transactions as
hex string after sending.
(Defaults to false)
.IP \[bu] 2
\f[I]get_tx_metadata\f[R] - boolean; (Optional) Return list of
transaction metadata needed to relay the transfer later.
(Defaults to false)
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_hash_list\f[R] - array of: string.
The tx hashes of every transaction.
.IP \[bu] 2
\f[I]tx_key_list\f[R] - array of: string.
The transaction keys for every transaction.
.IP \[bu] 2
\f[I]amount_list\f[R] - array of: integer.
The amount transferred for every transaction.
.IP \[bu] 2
\f[I]fee_list\f[R] - array of: integer.
The amount of fees paid for every transaction.
.IP \[bu] 2
\f[I]tx_blob_list\f[R] - array of: string.
The tx as hex string for every transaction.
.IP \[bu] 2
\f[I]tx_metadata_list\f[R] - array of: string.
List of transaction metadata needed to relay the transactions later.
.IP \[bu] 2
\f[I]multisig_txset\f[R] - string.
The set of signing keys used in a multisig transaction (empty for
non-multisig).
.IP \[bu] 2
\f[I]unsigned_txset\f[R] - string.
Set of unsigned tx for cold-signing purposes.
.PP
Example (In this example, \f[V]sweep_dust\f[R] returns nothing because
there are no funds to sweep):
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]sweep_dust\[dq],\[dq]params\[dq]:{\[dq]get_tx_keys\[dq]:true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]multisig_txset\[dq]: \[dq]\[dq],
    \[dq]unsigned_txset\[dq]: \[dq]\[dq]
  }
}
\f[R]
.fi
.SS \f[B]sweep_single\f[R]
.PP
Send all of a specific unlocked output to an address.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]address\f[R] - string; Destination public address.
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; Sweep transactions from this
account.
.IP \[bu] 2
\f[I]subaddr_indices\f[R] - array of unsigned int; (Optional) Sweep from
this set of subaddresses in the account.
.IP \[bu] 2
\f[I]priority\f[R] - unsigned int; (Optional) Priority for sending the
sweep transfer, partially determines fee.
.IP \[bu] 2
\f[I]mixin\f[R] - unsigned int; Number of outputs from the blockchain to
mix with (0 means no mixing).
.IP \[bu] 2
\f[I]ring_size\f[R] - unsigned int; Sets ringsize to n (mixin + 1).
.IP \[bu] 2
\f[I]unlock_time\f[R] - unsigned int; Number of blocks before the monero
can be spent (0 to not add a lock).
.IP \[bu] 2
\f[I]payment_id\f[R] - string; (Optional) Random 32-byte/64-character
hex string to identify a transaction.
.IP \[bu] 2
\f[I]get_tx_keys\f[R] - boolean; (Optional) Return the transaction keys
after sending.
.IP \[bu] 2
\f[I]key_image\f[R] - string; Key image of specific output to sweep.
.IP \[bu] 2
\f[I]below_amount\f[R] - unsigned int; (Optional) Include outputs below
this amount.
.IP \[bu] 2
\f[I]do_not_relay\f[R] - boolean; (Optional) If true, do not relay this
sweep transfer.
(Defaults to false)
.IP \[bu] 2
\f[I]get_tx_hex\f[R] - boolean; (Optional) return the transactions as
hex encoded string.
(Defaults to false)
.IP \[bu] 2
\f[I]get_tx_metadata\f[R] - boolean; (Optional) return the transaction
metadata as a string.
(Defaults to false)
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_hash_list\f[R] - array of: string.
The tx hashes of every transaction.
.IP \[bu] 2
\f[I]tx_key_list\f[R] - array of: string.
The transaction keys for every transaction.
.IP \[bu] 2
\f[I]amount_list\f[R] - array of: integer.
The amount transferred for every transaction.
.IP \[bu] 2
\f[I]fee_list\f[R] - array of: integer.
The amount of fees paid for every transaction.
.IP \[bu] 2
\f[I]tx_blob_list\f[R] - array of: string.
The tx as hex string for every transaction.
.IP \[bu] 2
\f[I]tx_metadata_list\f[R] - array of: string.
List of transaction metadata needed to relay the transactions later.
.IP \[bu] 2
\f[I]multisig_txset\f[R] - string.
The set of signing keys used in a multisig transaction (empty for
non-multisig).
.IP \[bu] 2
\f[I]unsigned_txset\f[R] - string.
Set of unsigned tx for cold-signing purposes.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]sweep_single\[dq],\[dq]params\[dq]:{\[dq]address\[dq]:\[dq]74Jsocx8xbpTBEjm3ncKE5LBQbiJouyCDaGhgSiebpvNDXZnTAbW2CmUR5SsBeae2pNk9WMVuz6jegkC4krUyqRjA6VjoLD\[dq],\[dq]ring_size\[dq]:7,\[dq]unlock_time\[dq]:0,\[dq]key_image\[dq]:\[dq]a7834459ef795d2efb6f665d2fd758c8d9288989d8d4c712a68f8023f7804a5e\[dq],\[dq]get_tx_keys\[dq]:true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]amount\[dq]: 27126892247503,
    \[dq]fee\[dq]: 14111630000,
    \[dq]multisig_txset\[dq]: \[dq]\[dq],
    \[dq]tx_blob\[dq]: \[dq]\[dq],
    \[dq]tx_hash\[dq]: \[dq]106d4391a031e5b735ded555862fec63233e34e5fa4fc7edcfdbe461c275ae5b\[dq],
    \[dq]tx_key\[dq]: \[dq]\[dq],
    \[dq]tx_metadata\[dq]: \[dq]\[dq],
    \[dq]unsigned_txset\[dq]: \[dq]\[dq]
  }
}
\f[R]
.fi
.SS \f[B]tag_accounts\f[R]
.PP
Apply a filtering tag to a list of accounts.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]tag\f[R] - string; Tag for the accounts.
.IP \[bu] 2
\f[I]accounts\f[R] - array of unsigned int; Tag this list of accounts.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]tag_accounts\[dq],\[dq]params\[dq]:{\[dq]tag\[dq]:\[dq]myTag\[dq],\[dq]accounts\[dq]:[0,1]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]transfer\f[R]
.PP
Send monero to a number of recipients.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]destinations\f[R] - array of destinations to receive XMR:
.RS 2
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount to send to each destination, in
atomic units.
.IP \[bu] 2
\f[I]address\f[R] - string; Destination public address.
.RE
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; (Optional) Transfer from this
account index.
(Defaults to 0)
.IP \[bu] 2
\f[I]subaddr_indices\f[R] - array of unsigned int; (Optional) Transfer
from this set of subaddresses.
(Defaults to 0)
.IP \[bu] 2
\f[I]priority\f[R] - unsigned int; Set a priority for the transaction.
Accepted Values are: 0-3 for: default, unimportant, normal, elevated,
priority.
.IP \[bu] 2
\f[I]mixin\f[R] - unsigned int; Number of outputs from the blockchain to
mix with (0 means no mixing).
.IP \[bu] 2
\f[I]ring_size\f[R] - unsigned int; Number of outputs to mix in the
transaction (this output + N decoys from the blockchain).
.IP \[bu] 2
\f[I]unlock_time\f[R] - unsigned int; Number of blocks before the monero
can be spent (0 to not add a lock).
.IP \[bu] 2
\f[I]payment_id\f[R] - string; (Optional) Random 32-byte/64-character
hex string to identify a transaction.
.IP \[bu] 2
\f[I]get_tx_key\f[R] - boolean; (Optional) Return the transaction key
after sending.
.IP \[bu] 2
\f[I]do_not_relay\f[R] - boolean; (Optional) If true, the newly created
transaction will not be relayed to the monero network.
(Defaults to false)
.IP \[bu] 2
\f[I]get_tx_hex\f[R] - boolean; Return the transaction as hex string
after sending (Defaults to false)
.IP \[bu] 2
\f[I]get_tx_metadata\f[R] - boolean; Return the metadata needed to relay
the transaction.
(Defaults to false)
.PP
Outputs:
.IP \[bu] 2
\f[I]amount\f[R] - Amount transferred for the transaction.
.IP \[bu] 2
\f[I]fee\f[R] - Integer value of the fee charged for the txn.
.IP \[bu] 2
\f[I]multisig_txset\f[R] - Set of multisig transactions in the process
of being signed (empty for non-multisig).
.IP \[bu] 2
\f[I]tx_blob\f[R] - Raw transaction represented as hex string, if
get_tx_hex is true.
.IP \[bu] 2
\f[I]tx_hash\f[R] - String for the publically searchable transaction
hash.
.IP \[bu] 2
\f[I]tx_key\f[R] - String for the transaction key if get_tx_key is true,
otherwise, blank string.
.IP \[bu] 2
\f[I]tx_metadata\f[R] - Set of transaction metadata needed to relay this
transfer later, if get_tx_metadata is true.
.IP \[bu] 2
\f[I]unsigned_txset\f[R] - String.
Set of unsigned tx for cold-signing purposes.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]transfer\[dq],\[dq]params\[dq]:{\[dq]destinations\[dq]:[{\[dq]amount\[dq]:100000000000,\[dq]address\[dq]:\[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq]},{\[dq]amount\[dq]:200000000000,\[dq]address\[dq]:\[dq]75sNpRwUtekcJGejMuLSGA71QFuK1qcCVLZnYRTfQLgFU5nJ7xiAHtR5ihioS53KMe8pBhH61moraZHyLoG4G7fMER8xkNv\[dq]}],\[dq]account_index\[dq]:0,\[dq]subaddr_indices\[dq]:[0],\[dq]priority\[dq]:0,\[dq]ring_size\[dq]:7,\[dq]get_tx_key\[dq]: true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]amount\[dq]: 300000000000,
    \[dq]fee\[dq]: 86897600000,
    \[dq]multisig_txset\[dq]: \[dq]\[dq],
    \[dq]tx_blob\[dq]: \[dq]\[dq],
    \[dq]tx_hash\[dq]: \[dq]7663438de4f72b25a0e395b770ea9ecf7108cd2f0c4b75be0b14a103d3362be9\[dq],
    \[dq]tx_key\[dq]: \[dq]25c9d8ec20045c80c93d665c9d3684aab7335f8b2cd02e1ba2638485afd1c70e236c4bdd7a2f1cb511dbf466f13421bdf8df988b7b969c448ca6239d7251490e4bf1bbf9f6ffacffdcdc93b9d1648ec499eada4d6b4e02ce92d4a1c0452e5d009fbbbf15b549df8856205a4c7bda6338d82c823f911acd00cb75850b198c5803\[dq],
    \[dq]tx_metadata\[dq]: \[dq]\[dq],
    \[dq]unsigned_txset\[dq]: \[dq]\[dq]
  }
}
\f[R]
.fi
.SS \f[B]transfer_split\f[R]
.PP
Same as transfer, but can split into more than one tx if necessary.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]destinations\f[R] - array of destinations to receive XMR:
.RS 2
.IP \[bu] 2
\f[I]amount\f[R] - unsigned int; Amount to send to each destination, in
atomic units.
.IP \[bu] 2
\f[I]address\f[R] - string; Destination public address.
.RE
.IP \[bu] 2
\f[I]account_index\f[R] - unsigned int; (Optional) Transfer from this
account index.
(Defaults to 0)
.IP \[bu] 2
\f[I]subaddr_indices\f[R] - array of unsigned int; (Optional) Transfer
from this set of subaddresses.
(Defaults to 0)
.IP \[bu] 2
\f[I]mixin\f[R] - unsigned int; Number of outputs from the blockchain to
mix with (0 means no mixing).
.IP \[bu] 2
\f[I]ring_size\f[R] - unsigned int; Sets ringsize to n (mixin + 1).
.IP \[bu] 2
\f[I]unlock_time\f[R] - unsigned int; Number of blocks before the monero
can be spent (0 to not add a lock).
.IP \[bu] 2
\f[I]payment_id\f[R] - string; (Optional) Random 32-byte/64-character
hex string to identify a transaction.
.IP \[bu] 2
\f[I]get_tx_keys\f[R] - boolean; (Optional) Return the transaction keys
after sending.
.IP \[bu] 2
\f[I]priority\f[R] - unsigned int; Set a priority for the transactions.
Accepted Values are: 0-3 for: default, unimportant, normal, elevated,
priority.
.IP \[bu] 2
\f[I]do_not_relay\f[R] - boolean; (Optional) If true, the newly created
transaction will not be relayed to the monero network.
(Defaults to false)
.IP \[bu] 2
\f[I]get_tx_hex\f[R] - boolean; Return the transactions as hex string
after sending
.IP \[bu] 2
\f[I]new_algorithm\f[R] - boolean; True to use the new transaction
construction algorithm, defaults to false.
.IP \[bu] 2
\f[I]get_tx_metadata\f[R] - boolean; Return list of transaction metadata
needed to relay the transfer later.
.PP
Outputs:
.IP \[bu] 2
\f[I]tx_hash_list\f[R] - array of: string.
The tx hashes of every transaction.
.IP \[bu] 2
\f[I]tx_key_list\f[R] - array of: string.
The transaction keys for every transaction.
.IP \[bu] 2
\f[I]amount_list\f[R] - array of: integer.
The amount transferred for every transaction.
.IP \[bu] 2
\f[I]fee_list\f[R] - array of: integer.
The amount of fees paid for every transaction.
.IP \[bu] 2
\f[I]tx_blob_list\f[R] - array of: string.
The tx as hex string for every transaction.
.IP \[bu] 2
\f[I]tx_metadata_list\f[R] - array of: string.
List of transaction metadata needed to relay the transactions later.
.IP \[bu] 2
\f[I]multisig_txset\f[R] - string.
The set of signing keys used in a multisig transaction (empty for
non-multisig).
.IP \[bu] 2
\f[I]unsigned_txset\f[R] - string.
Set of unsigned tx for cold-signing purposes.
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]transfer_split\[dq],\[dq]params\[dq]:{\[dq]destinations\[dq]:[{\[dq]amount\[dq]:1000000000000,\[dq]address\[dq]:\[dq]7BnERTpvL5MbCLtj5n9No7J5oE5hHiB3tVCK5cjSvCsYWD2WRJLFuWeKTLiXo5QJqt2ZwUaLy2Vh1Ad51K7FNgqcHgjW85o\[dq]},{\[dq]amount\[dq]:2000000000000,\[dq]address\[dq]:\[dq]75sNpRwUtekcJGejMuLSGA71QFuK1qcCVLZnYRTfQLgFU5nJ7xiAHtR5ihioS53KMe8pBhH61moraZHyLoG4G7fMER8xkNv\[dq]}],\[dq]account_index\[dq]:0,\[dq]subaddr_indices\[dq]:[0],\[dq]priority\[dq]:0,\[dq]ring_size\[dq]:7,\[dq]get_tx_key\[dq]: true}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]amount_list\[dq]: [3000000000000],
    \[dq]fee_list\[dq]: [85106400000],
    \[dq]multisig_txset\[dq]: \[dq]\[dq],
    \[dq]tx_hash_list\[dq]: [\[dq]c8d815f48f27d53fdaf198a74b292a91bfaf87529a9a9a9ee66079a890b3b58b\[dq]],
    \[dq]unsigned_txset\[dq]: \[dq]\[dq]
  }
}
\f[R]
.fi
.SS \f[B]untag_accounts\f[R]
.PP
Remove filtering tag from a list of accounts.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]accounts\f[R] - array of unsigned int; Remove tag from this list of
accounts.
.PP
Outputs: \f[I]None\f[R].
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://localhost:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]untag_accounts\[dq],\[dq]params\[dq]:{\[dq]accounts\[dq]:[1]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
  }
}
\f[R]
.fi
.SS \f[B]verify\f[R]
.PP
Verify a signature on a string.
.PP
Alias: \f[I]None\f[R].
.PP
Inputs:
.IP \[bu] 2
\f[I]data\f[R] - string; What should have been signed.
.IP \[bu] 2
\f[I]address\f[R] - string; Public address of the wallet used to
\f[V]sign\f[R] the data.
.IP \[bu] 2
\f[I]signature\f[R] - string; signature generated by \f[V]sign\f[R]
method.
.PP
Outputs:
.IP \[bu] 2
\f[I]good\f[R] - boolean;
.PP
Example:
.IP
.nf
\f[C]
$ curl -X POST http://127.0.0.1:18082/json_rpc -d \[aq]{\[dq]jsonrpc\[dq]:\[dq]2.0\[dq],\[dq]id\[dq]:\[dq]0\[dq],\[dq]method\[dq]:\[dq]verify\[dq],\[dq]params\[dq]:{\[dq]data\[dq]:\[dq]This is sample data to be signed\[dq],\[dq]address\[dq]:\[dq]55LTR8KniP4LQGJSPtbYDacR7dz8RBFnsfAKMaMuwUNYX6aQbBcovzDPyrQF9KXF9tVU6Xk3K8no1BywnJX6GvZX8yJsXvt\[dq],\[dq]signature\[dq]:\[dq]SigV14K6G151gycjiGxjQ74tKX6A2LwwghvuHjcDeuRFQio5LS6Gb27BNxjYQY1dPuUvXkEbGQUkiHSVLPj4nJAHRrrw3\[dq]}}\[aq] -H \[aq]Content-Type: application/json\[aq]
{
  \[dq]id\[dq]: \[dq]0\[dq],
  \[dq]jsonrpc\[dq]: \[dq]2.0\[dq],
  \[dq]result\[dq]: {
    \[dq]good\[dq]: true
  }
}
\f[R]
.fi
.SH REFERENCE
.PP
Reworked from
GetMonero.org (https://ww.getmonero.org/resources/developer-guides/wallet-rpc.html)
.SH SEE ALSO
.PP
Link to full documentation at:
<https://monerodocs.org/interacting/monero-wallet-rpc-reference/>
.PP
monero-wallet-cli(1), monero-wallet-gui(1)
